<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Tank Battle</title>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Bungee', cursive;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .scoreboard {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: min(85vw, 620px);
            max-width: 620px;
            margin-bottom: 10px;
            font-size: 1.2rem;
            color: #f1c40f;
            text-shadow: 0 0 8px rgba(241, 196, 15, 0.6);
        }
        .scoreboard span:first-child {
            text-align: left;
        }
        .scoreboard span:last-child {
            text-align: right;
        }
        .scoreboard .score-label {
            margin-right: 0.35em;
        }
        .scoreboard .player1-label {
            color: #2ecc71;
            text-shadow: 0 0 8px rgba(46, 204, 113, 0.6);
        }
        .scoreboard .player2-label {
            color: #3498db;
            text-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
        }
        canvas {
            background-color: #2c3e50;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            max-width: 100vw;
            max-height: 80vh;
        }
        h1 {
            font-size: 3rem;
            color: #3498db;
            text-shadow: 0 0 10px #3498db;
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            width: min(85vw, 620px);
            max-width: 620px;
            margin-top: 12px;
            gap: 18px;
        }
        .control-panel {
            flex: 1 1 calc(50% - 9px);
            background: #2c3e50;
            padding: 8px 12px;
            border-radius: 10px;
            box-shadow: 0 0 8px rgba(0,0,0,0.45);
            margin: 0;
        }
        .control-panel h2 {
            margin-top: 0;
            margin-bottom: 6px;
            font-size: 0.95rem;
            text-align: center;
            color: inherit;
            text-shadow: 0 0 6px rgba(0,0,0,0.4);
        }
        .control-panel ul {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }
        .control-panel li {
            margin-bottom: 4px;
            font-size: 0.75em;
            display: flex;
            justify-content: space-between;
        }
        .control-panel li strong {
            color: #f1c40f;
            margin-right: 1em;
        }
        .player1-panel {
            border: 1px solid rgba(46, 204, 113, 0.2);
        }
        .player2-panel {
            border: 1px solid rgba(52, 152, 219, 0.2);
        }
        .player1-panel h2 {
            color: #2ecc71;
            text-shadow: 0 0 8px rgba(46, 204, 113, 0.5);
        }
        .player2-panel h2 {
            color: #3498db;
            text-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Tank Battle</h1>
        <div class="scoreboard">
            <span><span class="score-label player1-label">Player 1:</span> <strong id="player1ScoreDisplay">0</strong></span>
            <span><span class="score-label player2-label">Player 2:</span> <strong id="player2ScoreDisplay">0</strong></span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div class="control-panel player1-panel">
                <h2>Player 1</h2>
                <ul>
                    <li><strong>Forward:</strong> W</li>
                    <li><strong>Backward:</strong> S</li>
                    <li><strong>Turn Left:</strong> A</li>
                    <li><strong>Turn Right:</strong> D</li>
                    <li><strong>Fire:</strong> Z</li>
                </ul>
            </div>
            <div class="control-panel player2-panel">
                <h2>Player 2</h2>
                <ul>
                    <li><strong>Forward:</strong> Up Arrow</li>
                    <li><strong>Backward:</strong> Down Arrow</li>
                    <li><strong>Turn Left:</strong> Left Arrow</li>
                    <li><strong>Turn Right:</strong> Right Arrow</li>
                    <li><strong>Fire:</strong> Forward Slash (/)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player1ScoreDisplay = document.getElementById('player1ScoreDisplay');
        const player2ScoreDisplay = document.getElementById('player2ScoreDisplay');

        // --- Game Setup ---
        function calculateOptimalCanvasDimensions() {
            // Calculate the maximum desired width based on window size
            const maxDesiredWidth = Math.min(window.innerWidth * 0.9, 1000);
            
            // Use the actual values: TANK_SIZE = 40, BARRIER_SIZE = TANK_SIZE * 1.2 = 48
            const gridSize = 48; // BARRIER_SIZE constant value
            
            // Calculate how many complete grid squares fit in the maximum desired width
            const maxGridColumns = Math.floor(maxDesiredWidth / gridSize);
            
            // Ensure we have at least a minimum number of columns for playability
            const minColumns = 10; // Minimum viable playing field
            const actualColumns = Math.max(maxGridColumns, minColumns);
            
            // Set canvas width to exactly fit those grid squares (maximizes space while staying grid-aligned)
            const alignedWidth = actualColumns * gridSize;
            const alignedHeight = alignedWidth * 0.6;
            
            return { width: alignedWidth, height: alignedHeight };
        }
        
        let dimensions = calculateOptimalCanvasDimensions();
        let canvasWidth = dimensions.width;
        let canvasHeight = dimensions.height;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        window.addEventListener('resize', () => {
            dimensions = calculateOptimalCanvasDimensions();
            canvasWidth = dimensions.width;
            canvasHeight = dimensions.height;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            generateBarriers(); // Regenerate barriers for new size
        });

        function drawGrid() {
            ctx.save();
            const step = 48; // BARRIER_SIZE = TANK_SIZE * 1.2 = 40 * 1.2 = 48
            const columns = Math.floor(canvas.width / step);
            const centerIndex = Math.floor(columns / 2);

            // Fill the two central columns with a lighter background for perfect symmetry
            if (columns >= 2) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.08)'; // Increased opacity for better visibility
                
                // For even number of columns, draw the two middle columns
                // For odd number of columns, draw the center column and the one to its right
                if (columns % 2 === 0) {
                    // Even columns: draw columns at centerIndex-1 and centerIndex
                    const leftCenterX = (centerIndex - 1) * step;
                    const rightCenterX = centerIndex * step;
                    ctx.fillRect(leftCenterX, 0, step, canvas.height);
                    ctx.fillRect(rightCenterX, 0, step, canvas.height);
                } else {
                    // Odd columns: draw center column and the one to its right
                    const centerX = centerIndex * step;
                    const rightCenterX = (centerIndex + 1) * step;
                    ctx.fillRect(centerX, 0, step, canvas.height);
                    if (centerIndex + 1 < columns) { // Make sure we don't go out of bounds
                        ctx.fillRect(rightCenterX, 0, step, canvas.height);
                    }
                }
            }

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.lineWidth = 1;

            for (let x = step; x < canvas.width; x += step) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = step; y < canvas.height; y += step) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- Audio ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playExplosionSound() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(0);
            source.stop(audioCtx.currentTime + 0.3);
        }
        
        function playBarrierHitSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        function playBarrierBreakSound() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.4;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0.7, audioCtx.currentTime);
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(0);
        }

        // --- Game State ---
        const keys = {};
        const bullets = [];
        const explosions = [];
        const barriers = []; // Array to store barriers
        let player1Score = 0;
        let player2Score = 0;

        const TANK_SIZE = 40; // Now a square
        const TURRET_LENGTH = 34; // Shortened by 25%
        const TANK_TRACK_WIDTH = 10; // Width of the tracks
        const TANK_SPEED = 2;
        const TURN_SPEED = 2.5 * Math.PI / 180;
        const BULLET_SPEED = 5;
        const FIRE_RATE = 500;
        const BARRIER_SIZE = TANK_SIZE * 1.2;
        const BARRIER_PADDING = 4;
        const BARRIER_SPAWN_CHANCE = 0.06;
        const BARRIER_MIN_LENGTH = 2;
        const BARRIER_MAX_LENGTH = 5;
        const BARRIER_TYPE_CHANCES = {
            indestructible: 0.2,
            moving: 0.15
        };
        const MOVING_BARRIER_SPEED = 1.3;
        const MOVING_BARRIER_RANGE_MULTIPLIER = 2.5;

        // Use the combined width for collision radius (main body + track width)
        const TANK_COLLISION_RADIUS = TANK_SIZE / 2; 
        const TANK_START_MARGIN = TANK_COLLISION_RADIUS + 20;

        class Tank {
            constructor(x, y, color, turretColor) {
                this.x = x;
                this.y = y;
                this.size = TANK_SIZE; 
                this.color = color;
                this.turretColor = turretColor;
                this.angle = 0; // Angle for the entire tank
                this.lastShotTime = 0;
                this.isHit = false;
            }

            draw() {
                if (this.isHit) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const bodyHeight = this.size - (2 * TANK_TRACK_WIDTH);

                // Tracks (now parallel to turret/movement - top and bottom)
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, TANK_TRACK_WIDTH); // Top track
                ctx.fillRect(-this.size / 2, this.size / 2 - TANK_TRACK_WIDTH, this.size, TANK_TRACK_WIDTH); // Bottom track

                // Main body (sits between tracks)
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size / 2, -bodyHeight / 2, this.size, bodyHeight);

                // Hatch/top detail
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, this.size / 3.5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Turret (locked to body)
                ctx.fillStyle = this.turretColor;
                ctx.beginPath();
                ctx.arc(0, 0, this.size / 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillRect(0, -5, TURRET_LENGTH, 10);
                
                ctx.restore();
            }
            
            rotate(direction) {
                 this.angle += TURN_SPEED * direction;
            }
            
            fire() {
                if (this.isHit) return;
                const now = Date.now();
                if (now - this.lastShotTime > FIRE_RATE) {
                    this.lastShotTime = now;
                    // Bullet spawns from the front of the turret
                    const bulletX = this.x + Math.cos(this.angle) * TURRET_LENGTH;
                    const bulletY = this.y + Math.sin(this.angle) * TURRET_LENGTH;
                    bullets.push(new Bullet(bulletX, bulletY, this.angle, this.turretColor));
                }
            }
        }
        
        class Barrier {
            constructor(x, y, width, height, options = {}) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = options.type || 'breakable';
                const resolvedHealth = options.health ?? 1;
                if (this.type === 'breakable') {
                    this.health = resolvedHealth;
                    this.maxHealth = resolvedHealth;
                } else {
                    this.health = Number.isFinite(resolvedHealth) ? resolvedHealth : Infinity;
                    this.maxHealth = this.health;
                }
                this.axis = options.axis || 'horizontal';
                this.speed = options.speed || 0;
                this.range = Math.max(0, options.range || 0);
                this.originX = x;
                this.originY = y;
                this.direction = options.initialDirection || 1;
                if (this.type === 'moving') {
                    if (this.axis === 'horizontal') {
                        const leftLimit = this.originX - this.width / 2;
                        const rightLimit = canvas.width - this.width / 2 - this.originX;
                        const maxRange = Math.max(0, Math.min(leftLimit, rightLimit));
                        this.range = Math.min(this.range, maxRange);
                    } else {
                        const topLimit = this.originY - this.height / 2;
                        const bottomLimit = canvas.height - this.height / 2 - this.originY;
                        const maxRange = Math.max(0, Math.min(topLimit, bottomLimit));
                        this.range = Math.min(this.range, maxRange);
                    }
                    if (this.range <= 0 || this.speed <= 0) {
                        this.speed = 0;
                        this.direction = 0;
                    }
                }
            }

            draw() {
                if (this.isDestroyed()) return;

                ctx.save();
                ctx.lineWidth = 2;

                if (this.type === 'breakable') {
                    const baseHue = 15;
                    let saturation = 50;
                    if (this.maxHealth === 3) {
                        saturation = 65;
                    } else if (this.maxHealth === 1) {
                        saturation = 35;
                    }
                    const healthRatio = this.health / this.maxHealth;
                    const brightness = 35 + 20 * healthRatio;
                    ctx.fillStyle = `hsl(${baseHue}, ${saturation}%, ${brightness}%)`;
                    ctx.strokeStyle = `hsl(${baseHue}, ${saturation}%, ${brightness - 20}%)`;
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);

                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const currentCracks = this.maxHealth - this.health;
                    
                    if (currentCracks >= 1) {
                        ctx.moveTo(this.x - this.width / 2 + 5, this.y - this.height / 2 + 5);
                        ctx.lineTo(this.x + this.width / 2 - 5, this.y + this.height / 2 - 5);
                    }
                    if (currentCracks >= 2) {
                        ctx.moveTo(this.x + this.width / 2 - 5, this.y - this.height / 2 + 5);
                        ctx.lineTo(this.x - this.width / 2 + 5, this.y + this.height / 2 - 5);
                    }
                    ctx.stroke();
                } else if (this.type === 'indestructible') {
                    const gradient = ctx.createLinearGradient(this.x - this.width / 2, this.y - this.height / 2, this.x + this.width / 2, this.y + this.height / 2);
                    gradient.addColorStop(0, '#95a5a6');
                    gradient.addColorStop(1, '#7f8c8d');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#bdc3c7';
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                } else if (this.type === 'moving') {
                    const glow = this.axis === 'horizontal' ? '#f39c12' : '#9b59b6';
                    ctx.fillStyle = glow;
                    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                    ctx.shadowColor = glow;
                    ctx.shadowBlur = 12;
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
                ctx.restore();
            }

            takeDamage() {
                if (this.type !== 'breakable') return;
                this.health--;
            }

            isDestroyed() {
                return this.type === 'breakable' && this.health <= 0;
            }

            update() {
                if (this.type !== 'moving' || this.isDestroyed() || this.direction === 0 || this.speed <= 0) return;
                if (this.axis === 'horizontal') {
                    this.x += this.speed * this.direction;
                    const displacement = this.x - this.originX;
                    if (Math.abs(displacement) >= this.range) {
                        this.direction *= -1;
                        const sign = Math.sign(displacement) || this.direction;
                        this.x = this.originX + sign * this.range;
                    }
                    const minX = this.width / 2;
                    const maxX = canvas.width - this.width / 2;
                    if (this.x <= minX) {
                        this.x = minX;
                        this.direction = 1;
                    } else if (this.x >= maxX) {
                        this.x = maxX;
                        this.direction = -1;
                    }
                } else {
                    this.y += this.speed * this.direction;
                    const displacement = this.y - this.originY;
                    if (Math.abs(displacement) >= this.range) {
                        this.direction *= -1;
                        const sign = Math.sign(displacement) || this.direction;
                        this.y = this.originY + sign * this.range;
                    }
                    const minY = this.height / 2;
                    const maxY = canvas.height - this.height / 2;
                    if (this.y <= minY) {
                        this.y = minY;
                        this.direction = 1;
                    } else if (this.y >= maxY) {
                        this.y = maxY;
                        this.direction = -1;
                    }
                }
            }
        }

        class Bullet {
            constructor(x, y, angle, color) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.angle = angle;
                this.color = color;
                this.speed = BULLET_SPEED;
                this.hasBounced = false;
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = TANK_SIZE * 1.5; 
                this.lifespan = 60;
                this.frame = 0;
                this.particles = [];
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        angle: Math.random() * Math.PI * 2,
                        speed: Math.random() * 3 + 1,
                        size: Math.random() * 5 + 2,
                        x: 0,
                        y: 0
                    });
                }
            }

            update() {
                this.frame++;
                if (this.frame > this.lifespan) return;
                this.radius = (this.frame / this.lifespan) * this.maxRadius;
                this.particles.forEach(p => {
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                    p.speed *= 0.95;
                });
            }

            draw() {
                if (this.frame > this.lifespan) return;
                const alpha = 1 - (this.frame / this.lifespan);
                ctx.save();
                ctx.translate(this.x, this.y);
                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, ${Math.floor(200 * alpha)}, 0, ${alpha})`;
                    ctx.fill();
                });
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 165, 0, ${alpha * 0.8})`;
                ctx.shadowBlur = 20 * alpha;
                ctx.shadowColor = `rgba(255, 255, 0, ${alpha})`;
                ctx.fill();
                ctx.restore();
            }

            isFinished() {
                return this.frame > this.lifespan;
            }
        }
        
        const player1 = new Tank(TANK_START_MARGIN, canvas.height / 2, '#2ecc71', '#27ae60');
        player1.angle = 0;

        const player2 = new Tank(canvas.width - TANK_START_MARGIN, canvas.height / 2, '#3498db', '#2980b9');
        player2.angle = Math.PI;

        function updateScoreboard() {
            player1ScoreDisplay.textContent = player1Score;
            player2ScoreDisplay.textContent = player2Score;
        }

        function bounceBulletOffBarrier(bullet, barrier) {
            const dx = bullet.x - barrier.x;
            const dy = bullet.y - barrier.y;
            const halfWidth = barrier.width / 2;
            const halfHeight = barrier.height / 2;
            const overlapX = halfWidth + bullet.radius - Math.abs(dx);
            const overlapY = halfHeight + bullet.radius - Math.abs(dy);

            if (overlapX < overlapY) {
                const approach = Math.cos(bullet.angle);
                bullet.angle = Math.PI - bullet.angle;
                const direction = dx === 0 ? (approach >= 0 ? 1 : -1) : (dx > 0 ? 1 : -1);
                bullet.x = barrier.x + direction * (halfWidth + bullet.radius + 0.1);
            } else {
                const approach = Math.sin(bullet.angle);
                bullet.angle = -bullet.angle;
                const direction = dy === 0 ? (approach >= 0 ? 1 : -1) : (dy > 0 ? 1 : -1);
                bullet.y = barrier.y + direction * (halfHeight + bullet.radius + 0.1);
            }
        }
        
        function generateBarriers() {
            barriers.length = 0;
            const barrierSize = BARRIER_SIZE; // Grid cell size for placement
            // Remove padding - barriers now fill the entire grid square
            const barrierInteriorSize = barrierSize; // Full size instead of padded size
            const gridCols = Math.floor((canvas.width / 2) / barrierSize);
            const gridRows = Math.floor(canvas.height / barrierSize);
            const occupied = new Set();
            const safeZoneCols = Math.ceil((TANK_START_MARGIN + TANK_COLLISION_RADIUS) / barrierSize);

            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const key = `${col},${row}`;
                    if (occupied.has(key) || col < safeZoneCols) continue;

                    if (Math.random() < BARRIER_SPAWN_CHANCE) {
                        const typeRoll = Math.random();
                        let barrierType = 'breakable';
                        if (typeRoll < BARRIER_TYPE_CHANCES.indestructible) {
                            barrierType = 'indestructible';
                        } else if (typeRoll < BARRIER_TYPE_CHANCES.indestructible + BARRIER_TYPE_CHANCES.moving) {
                            barrierType = 'moving';
                        }

                        let wallLength = Math.floor(Math.random() * (BARRIER_MAX_LENGTH - BARRIER_MIN_LENGTH + 1)) + BARRIER_MIN_LENGTH;
                        let direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                        if (barrierType === 'moving') {
                            wallLength = 1;
                        }

                        let currentCol = col;
                        let currentRow = row;

                        for (let i = 0; i < wallLength; i++) {
                            const currentKey = `${currentCol},${currentRow}`;
                            
                            if ((direction === 'horizontal' && currentCol >= gridCols) || (direction === 'vertical' && currentRow >= gridRows) || occupied.has(currentKey)) break;
                            
                            const x = currentCol * barrierSize + barrierSize / 2;
                            const y = currentRow * barrierSize + barrierSize / 2;
                            const randomHealth = Math.floor(Math.random() * 3) + 1;
                            const baseOptions = { type: barrierType };
                            if (barrierType === 'breakable') {
                                baseOptions.health = randomHealth;
                            } else if (barrierType === 'moving') {
                                baseOptions.axis = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                                baseOptions.speed = MOVING_BARRIER_SPEED + Math.random() * 0.6;
                                baseOptions.range = barrierSize * MOVING_BARRIER_RANGE_MULTIPLIER;
                                baseOptions.initialDirection = Math.random() < 0.5 ? 1 : -1;
                                baseOptions.health = Infinity;
                            }
                            
                            occupied.add(currentKey);
                            const mirrorOptions = Object.assign({}, baseOptions);
                            if (baseOptions.type === 'moving') {
                                mirrorOptions.initialDirection = -(baseOptions.initialDirection || 1);
                            }
                            barriers.push(new Barrier(x, y, barrierInteriorSize, barrierInteriorSize, Object.assign({}, baseOptions)));
                            barriers.push(new Barrier(canvas.width - x, y, barrierInteriorSize, barrierInteriorSize, mirrorOptions));
                            
                            if (direction === 'horizontal') currentCol++;
                            else currentRow++;
                        }
                    }
                }
            }
        }

        function destroyTank(tank, isPlayer1Tank) {
            if (tank.isHit) return;
            if (isPlayer1Tank) {
                player2Score++;
            } else {
                player1Score++;
            }
            updateScoreboard();
            const explosion = new Explosion(tank.x, tank.y);
            explosions.push(explosion);
            playExplosionSound();
            tank.isHit = true;
            const respawnDelay = explosion.lifespan * (1000 / 60);
            setTimeout(() => resetTank(tank, isPlayer1Tank), respawnDelay);
        }

        function tankOverlapsBarrier(tank, barrier) {
            return tank.x + TANK_COLLISION_RADIUS > barrier.x - barrier.width / 2 &&
                   tank.x - TANK_COLLISION_RADIUS < barrier.x + barrier.width / 2 &&
                   tank.y + TANK_COLLISION_RADIUS > barrier.y - barrier.height / 2 &&
                   tank.y - TANK_COLLISION_RADIUS < barrier.y + barrier.height / 2;
        }
        
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function handleTankMovement(tank, forwardKey, backwardKey, leftKey, rightKey, otherTank) {
             if (tank.isHit) return;
             const isPlayer1Tank = tank === player1;

            // --- Rotation ---
            if (keys[leftKey]) tank.rotate(-1);
            if (keys[rightKey]) tank.rotate(1);
            
            // --- Movement ---
            let moveDirection = 0;
            if (keys[forwardKey]) moveDirection = 1;
            if (keys[backwardKey]) moveDirection = -1;
            
            if (moveDirection !== 0) {
                const moveX = Math.cos(tank.angle) * TANK_SPEED * moveDirection;
                const moveY = Math.sin(tank.angle) * TANK_SPEED * moveDirection;
                const nextX = tank.x + moveX;
                const nextY = tank.y + moveY;

                let collision = false;
                // Barrier collision (using AABB with the TANK_COLLISION_RADIUS)
                for (const barrier of barriers) {
                    if (barrier.isDestroyed()) continue;
                    if (nextX + TANK_COLLISION_RADIUS > barrier.x - barrier.width/2 && nextX - TANK_COLLISION_RADIUS < barrier.x + barrier.width/2 &&
                        nextY + TANK_COLLISION_RADIUS > barrier.y - barrier.height/2 && nextY - TANK_COLLISION_RADIUS < barrier.y + barrier.height/2) {
                        if (barrier.type === 'moving') {
                            destroyTank(tank, isPlayer1Tank);
                        }
                        collision = true; break;
                    }
                }
                // Player collision (using circular collision for tanks)
                if (Math.hypot(nextX - otherTank.x, nextY - otherTank.y) < (TANK_COLLISION_RADIUS * 2)) {
                    collision = true;
                }

                if (!collision) {
                    tank.x = nextX;
                    tank.y = nextY;
                }
            }

            // Clamp to screen bounds
            tank.x = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.width - TANK_COLLISION_RADIUS, tank.x));
            tank.y = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.height - TANK_COLLISION_RADIUS, tank.y));
        }

        function handleInput() {
            handleTankMovement(player1, 'KeyW', 'KeyS', 'KeyA', 'KeyD', player2);
            if (keys['KeyZ']) player1.fire();
           
            handleTankMovement(player2, 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', player1);
            if (keys['Slash']) player2.fire();
        }
        
        function checkCollisions() {
            bulletsLoop: for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Bullet-barrier collision
                for (let j = barriers.length - 1; j >= 0; j--) {
                    const barrier = barriers[j];
                    if (barrier.isDestroyed()) continue;
                    if (bullet.x > barrier.x - barrier.width / 2 && bullet.x < barrier.x + barrier.width / 2 &&
                        bullet.y > barrier.y - barrier.height / 2 && bullet.y < barrier.y + barrier.height / 2) {
                        
                        if (barrier.type === 'breakable') {
                            const hadMoreThanOneHealth = barrier.health > 1;
                            barrier.takeDamage();
                            if (barrier.isDestroyed()) {
                                playBarrierBreakSound();
                                barriers.splice(j, 1);
                                bullets.splice(i, 1);
                                continue bulletsLoop;
                            }

                            playBarrierHitSound();

                            if (!bullet.hasBounced && hadMoreThanOneHealth) {
                                bounceBulletOffBarrier(bullet, barrier);
                                bullet.hasBounced = true;
                                continue bulletsLoop;
                            }
                        } else {
                            playBarrierHitSound();
                            if (!bullet.hasBounced) {
                                bounceBulletOffBarrier(bullet, barrier);
                                bullet.hasBounced = true;
                                continue bulletsLoop;
                            }
                        }

                        bullets.splice(i, 1);
                        continue bulletsLoop;
                    }
                }

                // Bullet-tank collision
                const dist1 = Math.hypot(bullet.x - player1.x, bullet.y - player1.y);
                if (dist1 < TANK_COLLISION_RADIUS && !player1.isHit) { // Use TANK_COLLISION_RADIUS for bullet-tank
                    bullets.splice(i, 1);
                    destroyTank(player1, true);
                    continue; 
                }
                
                const dist2 = Math.hypot(bullet.x - player2.x, bullet.y - player2.y);
                if (dist2 < TANK_COLLISION_RADIUS && !player2.isHit) { // Use TANK_COLLISION_RADIUS for bullet-tank
                    bullets.splice(i, 1);
                    destroyTank(player2, false);
                    continue;
                }
                
                if (bullet.x - bullet.radius <= 0) {
                    if (!bullet.hasBounced) {
                        bullet.angle = Math.PI - bullet.angle;
                        bullet.x = bullet.radius + 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }

                if (bullet.x + bullet.radius >= canvas.width) {
                    if (!bullet.hasBounced) {
                        bullet.angle = Math.PI - bullet.angle;
                        bullet.x = canvas.width - bullet.radius - 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }

                if (bullet.y - bullet.radius <= 0) {
                    if (!bullet.hasBounced) {
                        bullet.angle = -bullet.angle;
                        bullet.y = bullet.radius + 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }

                if (bullet.y + bullet.radius >= canvas.height) {
                    if (!bullet.hasBounced) {
                        bullet.angle = -bullet.angle;
                        bullet.y = canvas.height - bullet.radius - 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }
            }
        }
        
        function resetTank(tank, isPlayer1) {
            if(isPlayer1){
                tank.x = TANK_START_MARGIN;
                tank.y = canvas.height / 2;
                tank.angle = 0;
            } else {
                tank.x = canvas.width - TANK_START_MARGIN;
                tank.y = canvas.height / 2;
                tank.angle = Math.PI;
            }
            tank.isHit = false;
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            handleInput();

            barriers.forEach(barrier => {
                barrier.update();
                if (barrier.type === 'moving') {
                    if (!player1.isHit && tankOverlapsBarrier(player1, barrier)) {
                        destroyTank(player1, true);
                    }
                    if (!player2.isHit && tankOverlapsBarrier(player2, barrier)) {
                        destroyTank(player2, false);
                    }
                }
                barrier.draw();
            });
            
            bullets.forEach(bullet => {
                bullet.update();
                bullet.draw();
            });
            checkCollisions();

            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.update();
                explosion.draw();
                if (explosion.isFinished()) {
                    explosions.splice(i, 1);
                }
            }

            player1.draw();
            player2.draw();
            requestAnimationFrame(gameLoop);
        }

        generateBarriers();
        updateScoreboard();
        gameLoop();
    </script>
</body>
</html>
