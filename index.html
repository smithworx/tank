<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Battle</title>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Bungee', cursive;
            overflow-x: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%;
            max-width: none;
        }
        .scoreboard {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: min(95vw, 800px);
            max-width: 800px;
            margin: 5px 0;
            font-size: 1.2rem;
            color: #f1c40f;
            text-shadow: 0 0 8px rgba(241, 196, 15, 0.6);
        }
        .scoreboard span:first-child {
            text-align: left;
        }
        .scoreboard span:last-child {
            text-align: right;
        }
        .scoreboard .score-label {
            margin-right: 0.35em;
        }
        .scoreboard .player1-label {
            color: #e74c3c;
            text-shadow: 0 0 8px rgba(231, 76, 60, 0.6);
        }
        .scoreboard .player2-label {
            color: #3498db;
            text-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
        }
        canvas {
            background-color: #2c3e50;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            max-width: 98vw;
            max-height: 85vh;
        }
        h1 {
            font-size: 2.5rem;
            color: #3498db;
            text-shadow: 0 0 10px #3498db;
            margin: 5px 0;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            width: min(85vw, 620px);
            max-width: 620px;
            margin-top: 12px;
            gap: 18px;
        }
        .control-panel {
            flex: 1 1 calc(50% - 9px);
            background: #2c3e50;
            padding: 8px 12px;
            border-radius: 10px;
            box-shadow: 0 0 8px rgba(0,0,0,0.45);
            margin: 0;
        }
        .control-panel h2 {
            margin-top: 0;
            margin-bottom: 6px;
            font-size: 0.95rem;
            text-align: center;
            color: inherit;
            text-shadow: 0 0 6px rgba(0,0,0,0.4);
        }
        .control-panel ul {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }
        .control-panel li {
            margin-bottom: 4px;
            font-size: 0.75em;
            display: flex;
            justify-content: space-between;
        }
        .control-panel li strong {
            color: #f1c40f;
            margin-right: 1em;
        }
        .player1-panel {
            border: 1px solid rgba(231, 76, 60, 0.2);
        }
        .player2-panel {
            border: 1px solid rgba(52, 152, 219, 0.2);
        }
        .player1-panel h2 {
            color: #e74c3c;
            text-shadow: 0 0 8px rgba(231, 76, 60, 0.5);
        }
        .player2-panel h2 {
            color: #3498db;
            text-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
        }
        
        .game-mode-selector {
            margin: 10px 0;
            text-align: center;
        }
        
        .game-mode-selector h2 {
            color: #f1c40f;
            font-size: 1.3rem;
            margin: 5px 0 10px 0;
            text-shadow: 0 0 8px rgba(241, 196, 15, 0.6);
        }
        
        .mode-btn {
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0 10px;
            border-radius: 8px;
            font-family: 'Bungee', cursive;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .mode-btn:hover {
            background: linear-gradient(145deg, #5dade2, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .mode-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Tank Battle</h1>
        <div id="gameModeSelector" class="game-mode-selector">
            <h2>Select Game Mode</h2>
            <button id="twoPlayerBtn" class="mode-btn">Two Player</button>
            <button id="vsAIBtn" class="mode-btn">vs AI</button>
            <button id="ctfBtn" class="mode-btn">Capture the Flag</button>
        </div>
        <div class="scoreboard" id="scoreboard" style="display: none;">
            <span><span class="score-label player1-label">Player 1:</span> <strong id="player1ScoreDisplay">0</strong></span>
            <span><span class="score-label player2-label">Player 2:</span> <strong id="player2ScoreDisplay">0</strong></span>
        </div>
        <canvas id="gameCanvas" style="display: none;"></canvas>
        <div class="controls" id="controls" style="display: none;">
            <div class="control-panel player1-panel">
                <h2>Player 1</h2>
                <ul>
                    <li><strong>Forward:</strong> W</li>
                    <li><strong>Backward:</strong> S</li>
                    <li><strong>Turn Left:</strong> A</li>
                    <li><strong>Turn Right:</strong> D</li>
                    <li><strong>Fire:</strong> Z</li>
                </ul>
            </div>
            <div class="control-panel player2-panel">
                <h2>Player 2</h2>
                <ul>
                    <li><strong>Forward:</strong> Up Arrow</li>
                    <li><strong>Backward:</strong> Down Arrow</li>
                    <li><strong>Turn Left:</strong> Left Arrow</li>
                    <li><strong>Turn Right:</strong> Right Arrow</li>
                    <li><strong>Fire:</strong> Forward Slash (/)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player1ScoreDisplay = document.getElementById('player1ScoreDisplay');
        const player2ScoreDisplay = document.getElementById('player2ScoreDisplay');

        // --- Game Setup ---
        function calculateOptimalCanvasDimensions() {
            // Calculate the maximum desired width based on window size - use more space
            const maxDesiredWidth = Math.min(window.innerWidth * 0.95, 1400);
            
            // Calculate available height (account for UI elements)
            const uiHeight = 150; // Reduced height due to more compact UI
            const maxDesiredHeight = Math.min(window.innerHeight - uiHeight, 1000);
            
            // Use the actual values: TANK_SIZE = 40, BARRIER_SIZE = TANK_SIZE * 1.2 = 48
            const gridSize = 48; // BARRIER_SIZE constant value
            
            // Calculate how many complete grid squares fit in both dimensions
            const maxGridColumns = Math.floor(maxDesiredWidth / gridSize);
            const maxGridRows = Math.floor(maxDesiredHeight / gridSize);
            
            // Ensure we have at least minimum dimensions for playability
            const minColumns = 12; // Increased minimum for larger field
            const minRows = 8;     // Minimum viable height
            const actualColumns = Math.max(maxGridColumns, minColumns);
            const actualRows = Math.max(maxGridRows, minRows);
            
            // Set canvas dimensions to exactly fit those grid squares
            const alignedWidth = actualColumns * gridSize;
            const alignedHeight = actualRows * gridSize;
            
            return { width: alignedWidth, height: alignedHeight };
        }
        
        let dimensions = calculateOptimalCanvasDimensions();
        let canvasWidth = dimensions.width;
        let canvasHeight = dimensions.height;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        window.addEventListener('resize', () => {
            dimensions = calculateOptimalCanvasDimensions();
            canvasWidth = dimensions.width;
            canvasHeight = dimensions.height;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            generateBarriers(); // Regenerate barriers for new size
        });

        function drawGrid() {
            ctx.save();
            const step = 48; // BARRIER_SIZE = TANK_SIZE * 1.2 = 40 * 1.2 = 48
            const columns = Math.floor(canvas.width / step);
            const centerIndex = Math.floor(columns / 2);

            // Fill the two central columns with a lighter background for perfect symmetry
            if (columns >= 2) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.08)'; // Increased opacity for better visibility
                
                // For even number of columns, draw two middle columns
                // For odd number of columns, draw just the center column
                if (columns % 2 === 0) {
                    // Even columns: draw the two middle columns at centerIndex-1 and centerIndex
                    const leftCenterX = (centerIndex - 1) * step;
                    const rightCenterX = centerIndex * step;
                    ctx.fillRect(leftCenterX, 0, step, canvas.height);
                    ctx.fillRect(rightCenterX, 0, step, canvas.height);
                } else {
                    // Odd columns: draw just the center column
                    const centerX = centerIndex * step;
                    ctx.fillRect(centerX, 0, step, canvas.height);
                }
            }

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.lineWidth = 1;

            for (let x = step; x < canvas.width; x += step) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = step; y < canvas.height; y += step) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- Enhanced Audio System ---
        let audioCtx;
        let masterGain;
        let musicGain;
        let sfxGain;
        let backgroundMusic;
        let audioEnabled = true;
        
        // Initialize audio context (requires user interaction)
        function initializeAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master gain for volume control
                masterGain = audioCtx.createGain();
                masterGain.gain.setValueAtTime(0.7, audioCtx.currentTime);
                masterGain.connect(audioCtx.destination);
                
                // Create separate gain nodes for music and sound effects
                musicGain = audioCtx.createGain();
                musicGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                musicGain.connect(masterGain);
                
                sfxGain = audioCtx.createGain();
                sfxGain.gain.setValueAtTime(0.8, audioCtx.currentTime);
                sfxGain.connect(masterGain);
                
                // Background music disabled
                // startBackgroundMusic();
            }
        }
        
        // Background music using procedural generation
        function startBackgroundMusic() {
            if (!audioCtx || !audioEnabled) return;
            
            const playMusicNote = (frequency, duration, delay = 0) => {
                const oscillator = audioCtx.createOscillator();
                const noteGain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime + delay);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(frequency * 2, audioCtx.currentTime + delay);
                filter.Q.setValueAtTime(1, audioCtx.currentTime + delay);
                
                noteGain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
                noteGain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + delay + 0.1);
                noteGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + duration);
                
                oscillator.connect(filter);
                filter.connect(noteGain);
                noteGain.connect(musicGain);
                
                oscillator.start(audioCtx.currentTime + delay);
                oscillator.stop(audioCtx.currentTime + delay + duration);
            };
            
            // Simple ambient battle music loop
            const playMusicLoop = () => {
                if (!audioEnabled || !audioCtx) return;
                
                // Bass line
                playMusicNote(55, 2, 0);   // A1
                playMusicNote(65.4, 2, 2); // C2
                playMusicNote(73.4, 2, 4); // D2
                playMusicNote(55, 2, 6);   // A1
                
                // Melody
                playMusicNote(220, 1, 1);   // A3
                playMusicNote(261.6, 1, 2.5); // C4
                playMusicNote(293.7, 1, 4);   // D4
                playMusicNote(220, 1.5, 5.5); // A3
                
                // Schedule next loop
                setTimeout(playMusicLoop, 8000);
            };
            
            playMusicLoop();
        }
        
        function playExplosionSound() {
            if (!audioCtx || !audioEnabled) return;
            
            // Enhanced explosion with multiple layers
            const duration = 0.6;
            
            // Low frequency boom
            const boomOsc = audioCtx.createOscillator();
            const boomGain = audioCtx.createGain();
            boomOsc.type = 'sine';
            boomOsc.frequency.setValueAtTime(60, audioCtx.currentTime);
            boomOsc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.3);
            boomGain.gain.setValueAtTime(0.8, audioCtx.currentTime);
            boomGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
            boomOsc.connect(boomGain);
            boomGain.connect(sfxGain);
            boomOsc.start();
            boomOsc.stop(audioCtx.currentTime + 0.4);
            
            // High frequency crack
            const crackOsc = audioCtx.createOscillator();
            const crackGain = audioCtx.createGain();
            crackOsc.type = 'square';
            crackOsc.frequency.setValueAtTime(1000, audioCtx.currentTime);
            crackOsc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            crackGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            crackGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            crackOsc.connect(crackGain);
            crackGain.connect(sfxGain);
            crackOsc.start();
            crackOsc.stop(audioCtx.currentTime + 0.2);
            
            // Noise burst
            const bufferSize = audioCtx.sampleRate * 0.3;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.5;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.6, audioCtx.currentTime);
            source.connect(noiseGain);
            noiseGain.connect(sfxGain);
            source.start(0);
        }
        
        function playBulletFireSound() {
            if (!audioCtx || !audioEnabled) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.05);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(100, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(sfxGain);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.08);
        }
        
        function playBarrierHitSound() {
            if (!audioCtx || !audioEnabled) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(200, audioCtx.currentTime);
            filter.Q.setValueAtTime(5, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(sfxGain);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playBarrierBreakSound() {
            if (!audioCtx || !audioEnabled) return;
            
            // Cracking sound
            const crackOsc = audioCtx.createOscillator();
            const crackGain = audioCtx.createGain();
            crackOsc.type = 'square';
            crackOsc.frequency.setValueAtTime(400, audioCtx.currentTime);
            crackOsc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
            crackGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            crackGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            crackOsc.connect(crackGain);
            crackGain.connect(sfxGain);
            crackOsc.start();
            crackOsc.stop(audioCtx.currentTime + 0.3);
            
            // Debris sound
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.3;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const debrisGain = audioCtx.createGain();
            debrisGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            source.connect(debrisGain);
            debrisGain.connect(sfxGain);
            source.start(0);
        }
        
        function playTeleportSound() {
            if (!audioCtx || !audioEnabled) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.3);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
            filter.Q.setValueAtTime(10, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(sfxGain);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);
        }
        
        function playPowerUpSound() {
            if (!audioCtx || !audioEnabled) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
            filter.Q.setValueAtTime(5, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(sfxGain);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.4);
        }
        
        function playFlagCaptureSound() {
            if (!audioCtx || !audioEnabled) return;
            
            // Create a triumphant multi-layered victory sound
            const duration = 1.2;
            
            // Main ascending melody
            const melodyOsc = audioCtx.createOscillator();
            const melodyGain = audioCtx.createGain();
            const melodyFilter = audioCtx.createBiquadFilter();
            
            melodyOsc.type = 'sawtooth';
            melodyOsc.frequency.setValueAtTime(440, audioCtx.currentTime); // A4
            melodyOsc.frequency.exponentialRampToValueAtTime(660, audioCtx.currentTime + 0.2); // E5
            melodyOsc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.4); // A5
            melodyOsc.frequency.setValueAtTime(880, audioCtx.currentTime + 0.4);
            melodyOsc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.8); // E6
            
            melodyFilter.type = 'lowpass';
            melodyFilter.frequency.setValueAtTime(3000, audioCtx.currentTime);
            melodyFilter.Q.setValueAtTime(2, audioCtx.currentTime);
            
            melodyGain.gain.setValueAtTime(0, audioCtx.currentTime);
            melodyGain.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.1);
            melodyGain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.6);
            melodyGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            // Harmonic support (fifth)
            const harmonyOsc = audioCtx.createOscillator();
            const harmonyGain = audioCtx.createGain();
            
            harmonyOsc.type = 'triangle';
            harmonyOsc.frequency.setValueAtTime(659, audioCtx.currentTime); // E5
            harmonyOsc.frequency.exponentialRampToValueAtTime(990, audioCtx.currentTime + 0.2); // B5
            harmonyOsc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.4); // E6
            harmonyOsc.frequency.setValueAtTime(1320, audioCtx.currentTime + 0.4);
            harmonyOsc.frequency.exponentialRampToValueAtTime(1980, audioCtx.currentTime + 0.8); // B6
            
            harmonyGain.gain.setValueAtTime(0, audioCtx.currentTime);
            harmonyGain.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime + 0.15);
            harmonyGain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.6);
            harmonyGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            // Celebratory high sparkles
            const sparkleOsc = audioCtx.createOscillator();
            const sparkleGain = audioCtx.createGain();
            const sparkleFilter = audioCtx.createBiquadFilter();
            
            sparkleOsc.type = 'sine';
            sparkleOsc.frequency.setValueAtTime(2200, audioCtx.currentTime + 0.3);
            sparkleOsc.frequency.exponentialRampToValueAtTime(3300, audioCtx.currentTime + 0.5);
            sparkleOsc.frequency.exponentialRampToValueAtTime(2640, audioCtx.currentTime + 0.7);
            sparkleOsc.frequency.exponentialRampToValueAtTime(3960, audioCtx.currentTime + 0.9);
            
            sparkleFilter.type = 'highpass';
            sparkleFilter.frequency.setValueAtTime(1500, audioCtx.currentTime);
            sparkleFilter.Q.setValueAtTime(3, audioCtx.currentTime);
            
            sparkleGain.gain.setValueAtTime(0, audioCtx.currentTime + 0.3);
            sparkleGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.35);
            sparkleGain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.7);
            sparkleGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            // Connect all oscillators
            melodyOsc.connect(melodyFilter);
            melodyFilter.connect(melodyGain);
            melodyGain.connect(sfxGain);
            
            harmonyOsc.connect(harmonyGain);
            harmonyGain.connect(sfxGain);
            
            sparkleOsc.connect(sparkleFilter);
            sparkleFilter.connect(sparkleGain);
            sparkleGain.connect(sfxGain);
            
            // Start all oscillators
            melodyOsc.start();
            melodyOsc.stop(audioCtx.currentTime + duration);
            
            harmonyOsc.start();
            harmonyOsc.stop(audioCtx.currentTime + duration);
            
            sparkleOsc.start(audioCtx.currentTime + 0.3);
            sparkleOsc.stop(audioCtx.currentTime + duration);
        }
        
        function playTankMoveSound() {
            if (!audioCtx || !audioEnabled) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(40 + Math.random() * 20, audioCtx.currentTime);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(sfxGain);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        }
        
        function toggleAudio() {
            audioEnabled = !audioEnabled;
            if (masterGain) {
                masterGain.gain.setValueAtTime(audioEnabled ? 0.7 : 0, audioCtx.currentTime);
            }
        }

        // --- Game State ---
        const keys = {};
        const bullets = [];
        const explosions = [];
        const barriers = []; // Array to store barriers
        const hazards = []; // Array to store environmental hazards
        const powerUps = []; // Array to store power-ups
        let player1Score = 0;
        let player2Score = 0;
        
        // Game mode variables
        let gameMode = null; // 'twoPlayer', 'vsAI', or 'captureTheFlag'
        let gameRunning = false;
        let roundInProgress = false;
        
        // Power-up spawning
        let lastPowerUpSpawn = 0;
        
        // CTF variables
        let redFlag = null;
        let blueFlag = null;
        let redBase = null;
        let blueBase = null;

        const TANK_SIZE = 40; // Now a square
        const TURRET_LENGTH = 34; // Shortened by 25%
        const TANK_TRACK_WIDTH = 10; // Width of the tracks
        const TANK_SPEED = 2;
        const TURN_SPEED = 2.5 * Math.PI / 180;
        const BULLET_SPEED = 5;
        const FIRE_RATE = 500;
        const BARRIER_SIZE = TANK_SIZE * 1.2;
        const BARRIER_PADDING = 4;
        const BARRIER_SPAWN_CHANCE = 0.06;
        const BARRIER_MIN_LENGTH = 2;
        const BARRIER_MAX_LENGTH = 5;
        const BARRIER_TYPE_CHANCES = {
            indestructible: 0.2,
            moving: 0.15
        };
        const MOVING_BARRIER_SPEED = 1.3;
        const MOVING_BARRIER_RANGE_MULTIPLIER = 2.5;
        
        // Environmental hazard constants
        const HAZARD_SPAWN_CHANCE = 0.04;
        const HAZARD_TYPE_CHANCES = {
            lava: 0.3,
            teleporter: 0.25,
            conveyor: 0.25,
            ice: 0.2
        };
        const LAVA_DAMAGE_RATE = 1000; // Damage every 1000ms
        const CONVEYOR_FORCE = 1.5;
        const ICE_FRICTION = 0.95; // Reduced friction on ice
        const ICE_SLIDE_FORCE = 0.8; // Momentum preservation on ice

        // Power-up constants
        const POWERUP_SPAWN_INTERVAL = 15000; // Spawn every 15 seconds
        const POWERUP_MAX_ACTIVE = 3; // Maximum power-ups on field at once
        const POWERUP_TYPES = ['spread', 'rapid', 'bounce', 'pierce'];
        const POWERUP_SPAWN_ATTEMPTS = 20; // Max attempts to find valid spawn location

        // Use the combined width for collision radius (main body + track width)
        const TANK_COLLISION_RADIUS = TANK_SIZE / 2; 
        const TANK_START_MARGIN = TANK_COLLISION_RADIUS + 20;

        class Tank {
            constructor(x, y, color, turretColor) {
                this.x = x;
                this.y = y;
                this.size = TANK_SIZE; 
                this.color = color;
                this.turretColor = turretColor;
                this.angle = 0; // Angle for the entire tank
                this.lastShotTime = 0;
                this.isHit = false;
                this.trackHistory = []; // Store track positions for drawing trails
                this.lastTrackPosition = { x: x, y: y, angle: 0 };
                this.trackTimer = 0;
                
                // Power-up properties
                this.activePowerUp = null;
                this.powerUpEndTime = 0;
            }

            draw() {
                if (this.isHit) return;
                
                // Draw tracks first (behind the tank)
                this.drawTracks();
                
                // Draw tank body
                this.drawBody();
            }
            
            drawBody() {
                if (this.isHit) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const bodyHeight = this.size - (2 * TANK_TRACK_WIDTH);

                // Tracks (now parallel to turret/movement - top and bottom)
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, TANK_TRACK_WIDTH); // Top track
                ctx.fillRect(-this.size / 2, this.size / 2 - TANK_TRACK_WIDTH, this.size, TANK_TRACK_WIDTH); // Bottom track

                // Main body (sits between tracks)
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size / 2, -bodyHeight / 2, this.size, bodyHeight);

                // Hatch/top detail
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, this.size / 3.5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Turret (locked to body)
                ctx.fillStyle = this.turretColor;
                ctx.beginPath();
                ctx.arc(0, 0, this.size / 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillRect(0, -5, TURRET_LENGTH, 10);
                
                // Power-up visual effects
                if (this.activePowerUp) {
                    const now = Date.now();
                    const timeLeft = this.powerUpEndTime - now;
                    const totalDuration = new PowerUp(0, 0, this.activePowerUp).duration;
                    const progress = timeLeft / totalDuration;
                    
                    // Get power-up color
                    const powerUpColor = new PowerUp(0, 0, this.activePowerUp).color;
                    
                    // Pulsing glow effect
                    const pulseIntensity = 0.5 + 0.3 * Math.sin(now * 0.01);
                    ctx.shadowColor = powerUpColor;
                    ctx.shadowBlur = 20 * pulseIntensity;
                    
                    // Outer glow ring
                    ctx.strokeStyle = powerUpColor;
                    ctx.globalAlpha = 0.6 * progress * pulseIntensity;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Power-up symbol above tank
                    ctx.globalAlpha = 0.8 * progress;
                    ctx.fillStyle = powerUpColor;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const symbol = new PowerUp(0, 0, this.activePowerUp).symbol;
                    ctx.fillText(symbol, 0, -this.size * 0.6);
                    
                    // Reset alpha and shadow
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            }
            
            rotate(direction) {
                 this.angle += TURN_SPEED * direction;
            }
            
            updateTracks() {
                // Only add tracks when tank is moving
                const distance = Math.hypot(this.x - this.lastTrackPosition.x, this.y - this.lastTrackPosition.y);
                
                if (distance > 8) { // Add track every 8 pixels of movement
                    this.trackHistory.push({
                        x: this.lastTrackPosition.x,
                        y: this.lastTrackPosition.y,
                        angle: this.lastTrackPosition.angle,
                        life: 180 // Track fades over 3 seconds at 60fps
                    });
                    
                    this.lastTrackPosition = { x: this.x, y: this.y, angle: this.angle };
                    
                    // Limit track history to prevent memory issues
                    if (this.trackHistory.length > 50) {
                        this.trackHistory.shift();
                    }
                }
                
                // Update track lifespans and remove old tracks
                for (let i = this.trackHistory.length - 1; i >= 0; i--) {
                    this.trackHistory[i].life--;
                    if (this.trackHistory[i].life <= 0) {
                        this.trackHistory.splice(i, 1);
                    }
                }
            }
            
            drawTracks() {
                // Draw tracks before drawing the tank
                ctx.save();
                for (let i = 0; i < this.trackHistory.length; i++) {
                    const track = this.trackHistory[i];
                    const alpha = Math.max(0, track.life / 180) * 0.3; // Fade from 30% to 0% opacity
                    
                    if (alpha > 0) {
                        ctx.save();
                        ctx.translate(track.x, track.y);
                        ctx.rotate(track.angle);
                        ctx.globalAlpha = alpha;
                        
                        // Draw subtle track marks (two parallel lines for treads)
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        
                        // Left track
                        ctx.beginPath();
                        ctx.moveTo(-this.size / 3, -this.size / 2);
                        ctx.lineTo(-this.size / 3, this.size / 2);
                        ctx.stroke();
                        
                        // Right track
                        ctx.beginPath();
                        ctx.moveTo(this.size / 3, -this.size / 2);
                        ctx.lineTo(this.size / 3, this.size / 2);
                        ctx.stroke();
                        
                        // Add small tread marks
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 1;
                        for (let j = -this.size / 2; j <= this.size / 2; j += 4) {
                            // Left tread marks
                            ctx.beginPath();
                            ctx.moveTo(-this.size / 3 - 2, j);
                            ctx.lineTo(-this.size / 3 + 2, j);
                            ctx.stroke();
                            
                            // Right tread marks
                            ctx.beginPath();
                            ctx.moveTo(this.size / 3 - 2, j);
                            ctx.lineTo(this.size / 3 + 2, j);
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                }
                ctx.restore();
            }
            
            fire() {
                if (this.isHit) return;
                
                const now = Date.now();
                let currentFireRate = FIRE_RATE;
                
                // Check if power-up is still active
                if (this.activePowerUp && now > this.powerUpEndTime) {
                    this.activePowerUp = null;
                }
                
                // Adjust fire rate for rapid fire power-up
                if (this.activePowerUp === 'rapid') {
                    currentFireRate = FIRE_RATE * 0.3; // 3x faster firing
                }
                
                if (now - this.lastShotTime > currentFireRate) {
                    this.lastShotTime = now;
                    
                    // Bullet spawns from the front of the turret
                    const bulletX = this.x + Math.cos(this.angle) * TURRET_LENGTH;
                    const bulletY = this.y + Math.sin(this.angle) * TURRET_LENGTH;
                    
                    // Different firing patterns based on power-up
                    switch(this.activePowerUp) {
                        case 'spread':
                            // Fire 3 bullets in a spread pattern
                            const spreadAngle = 0.3; // 30 degree spread
                            for (let i = -1; i <= 1; i++) {
                                const angle = this.angle + (i * spreadAngle);
                                const bx = this.x + Math.cos(angle) * TURRET_LENGTH;
                                const by = this.y + Math.sin(angle) * TURRET_LENGTH;
                                const bullet = new Bullet(bx, by, angle, this.turretColor);
                                bullets.push(bullet);
                            }
                            break;
                            
                        case 'bounce':
                            // Fire bullet that can bounce off barriers
                            const bounceBullet = new Bullet(bulletX, bulletY, this.angle, this.turretColor);
                            bounceBullet.bounces = 3; // Can bounce 3 times
                            bullets.push(bounceBullet);
                            break;
                            
                        case 'pierce':
                            // Fire bullet that can go through barriers
                            const pierceBullet = new Bullet(bulletX, bulletY, this.angle, this.turretColor);
                            pierceBullet.pierce = true;
                            bullets.push(pierceBullet);
                            break;
                            
                        default:
                            // Normal bullet
                            bullets.push(new Bullet(bulletX, bulletY, this.angle, this.turretColor));
                            break;
                    }
                    
                    playBulletFireSound();
                }
            }
            
            collectPowerUp(powerUpData) {
                this.activePowerUp = powerUpData.type;
                this.powerUpEndTime = Date.now() + powerUpData.duration;
            }
        }
        
        class AITank extends Tank {
            constructor(x, y, color, turretColor) {
                super(x, y, color, turretColor);
                this.target = null; // The target tank (player)
                this.lastDecisionTime = 0;
                this.decisionInterval = 100; // Make decisions every 100ms
                this.strafeDirection = Math.random() > 0.5 ? 1 : -1; // Random initial strafe direction
                this.aggressiveness = 0.7; // How often to attack vs evade (0-1)
                this.accuracy = 0.8; // Accuracy multiplier for aiming
                this.patrolAngle = Math.random() * Math.PI * 2; // Random patrol direction
                this.lastStrafeChange = 0;
                this.strafeChangeInterval = 2000; // Change strafe direction every 2 seconds
            }

            update(playerTank) {
                if (this.isHit) return;
                
                this.target = playerTank;
                const now = Date.now();
                
                // Make AI decisions at regular intervals
                if (now - this.lastDecisionTime > this.decisionInterval) {
                    this.makeDecision();
                    this.lastDecisionTime = now;
                }
                
                // Change strafe direction periodically
                if (now - this.lastStrafeChange > this.strafeChangeInterval) {
                    this.strafeDirection *= -1;
                    this.lastStrafeChange = now;
                }
                
                this.updateTracks();
            }

            makeDecision() {
                if (!this.target || this.target.isHit) return;

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distance = Math.hypot(dx, dy);
                const angleToTarget = Math.atan2(dy, dx);

                // Calculate if we have a clear shot
                const hasLineOfSight = this.checkLineOfSight(this.target);

                if (distance < 200 && hasLineOfSight && Math.random() < this.aggressiveness) {
                    // Attack mode: aim and shoot
                    this.aimAtTarget(angleToTarget);
                    if (Math.random() < 0.6) { // 60% chance to fire when in attack mode
                        this.fire();
                    }
                    
                    // Strafe while attacking
                    this.strafe();
                } else if (distance > 300) {
                    // Approach mode: move toward player
                    this.moveToward(angleToTarget);
                } else {
                    // Tactical mode: maintain distance and look for opportunities
                    if (hasLineOfSight && Math.random() < 0.3) {
                        this.fire();
                    }
                    this.strafe();
                }
            }

            aimAtTarget(targetAngle) {
                // Add some inaccuracy based on AI accuracy setting
                const inaccuracy = (1 - this.accuracy) * (Math.random() - 0.5) * 0.5;
                const aimAngle = targetAngle + inaccuracy;
                
                // Smoothly rotate toward target
                let angleDiff = aimAngle - this.angle;
                
                // Normalize angle difference to [-π, π]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                if (Math.abs(angleDiff) > TURN_SPEED) {
                    this.rotate(angleDiff > 0 ? 1 : -1);
                } else {
                    this.angle = aimAngle;
                }
            }

            moveToward(targetAngle) {
                this.aimAtTarget(targetAngle);
                
                // Move forward if roughly facing the right direction
                const angleDiff = Math.abs(targetAngle - this.angle);
                if (angleDiff < Math.PI / 3) { // Within 60 degrees
                    this.moveForward();
                }
            }

            strafe() {
                // Move perpendicular to the target direction
                const strafeAngle = this.angle + (Math.PI / 2) * this.strafeDirection;
                const oldX = this.x;
                const oldY = this.y;
                
                this.x += Math.cos(strafeAngle) * TANK_SPEED * 0.7; // Slower strafe
                this.y += Math.sin(strafeAngle) * TANK_SPEED * 0.7;
                
                // Check for collisions and revert if necessary
                if (this.checkCollisions()) {
                    this.x = oldX;
                    this.y = oldY;
                    this.strafeDirection *= -1; // Change direction if blocked
                }
            }

            moveForward() {
                const oldX = this.x;
                const oldY = this.y;
                
                this.x += Math.cos(this.angle) * TANK_SPEED;
                this.y += Math.sin(this.angle) * TANK_SPEED;
                
                // Check for collisions and revert if necessary
                if (this.checkCollisions()) {
                    this.x = oldX;
                    this.y = oldY;
                }
            }

            checkCollisions() {
                // Check bounds
                if (this.x - TANK_COLLISION_RADIUS <= 0 || 
                    this.x + TANK_COLLISION_RADIUS >= canvas.width ||
                    this.y - TANK_COLLISION_RADIUS <= 0 || 
                    this.y + TANK_COLLISION_RADIUS >= canvas.height) {
                    return true;
                }

                // Check barrier collisions using the same logic as regular tanks
                for (let barrier of barriers) {
                    if (barrier.isDestroyed && barrier.isDestroyed()) continue;
                    if (this.x + TANK_COLLISION_RADIUS > barrier.x - barrier.width/2 && 
                        this.x - TANK_COLLISION_RADIUS < barrier.x + barrier.width/2 &&
                        this.y + TANK_COLLISION_RADIUS > barrier.y - barrier.height/2 && 
                        this.y - TANK_COLLISION_RADIUS < barrier.y + barrier.height/2) {
                        return true;
                    }
                }

                // Check collision with player tank
                if (this.target && Math.hypot(this.x - this.target.x, this.y - this.target.y) < (TANK_COLLISION_RADIUS * 2)) {
                    return true;
                }

                return false;
            }

            checkLineOfSight(target) {
                // Simple line of sight check - trace a line to the target
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance = Math.hypot(dx, dy);
                const steps = Math.floor(distance / 10); // Check every 10 pixels
                
                for (let i = 1; i < steps; i++) {
                    const checkX = this.x + (dx * i / steps);
                    const checkY = this.y + (dy * i / steps);
                    
                    // Check if this point intersects with any barrier using center-based coordinates
                    for (let barrier of barriers) {
                        if (barrier.isDestroyed && barrier.isDestroyed()) continue;
                        if (checkX > barrier.x - barrier.width/2 && checkX < barrier.x + barrier.width/2 &&
                            checkY > barrier.y - barrier.height/2 && checkY < barrier.y + barrier.height/2) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
        }
        
        class Barrier {
            constructor(x, y, width, height, options = {}) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = options.type || 'breakable';
                const resolvedHealth = options.health ?? 1;
                if (this.type === 'breakable') {
                    this.health = resolvedHealth;
                    this.maxHealth = resolvedHealth;
                } else {
                    this.health = Number.isFinite(resolvedHealth) ? resolvedHealth : Infinity;
                    this.maxHealth = this.health;
                }
                this.axis = options.axis || 'horizontal';
                this.speed = options.speed || 0;
                this.range = Math.max(0, options.range || 0);
                this.originX = x;
                this.originY = y;
                this.direction = options.initialDirection || 1;
                if (this.type === 'moving') {
                    if (this.axis === 'horizontal') {
                        const leftLimit = this.originX - this.width / 2;
                        const rightLimit = canvas.width - this.width / 2 - this.originX;
                        const maxRange = Math.max(0, Math.min(leftLimit, rightLimit));
                        this.range = Math.min(this.range, maxRange);
                    } else {
                        const topLimit = this.originY - this.height / 2;
                        const bottomLimit = canvas.height - this.height / 2 - this.originY;
                        const maxRange = Math.max(0, Math.min(topLimit, bottomLimit));
                        this.range = Math.min(this.range, maxRange);
                    }
                    if (this.range <= 0 || this.speed <= 0) {
                        this.speed = 0;
                        this.direction = 0;
                    }
                }
            }

            draw() {
                if (this.isDestroyed()) return;

                ctx.save();
                ctx.lineWidth = 2;

                if (this.type === 'breakable') {
                    const baseHue = 15;
                    let saturation = 50;
                    if (this.maxHealth === 3) {
                        saturation = 65;
                    } else if (this.maxHealth === 1) {
                        saturation = 35;
                    }
                    const healthRatio = this.health / this.maxHealth;
                    const brightness = 35 + 20 * healthRatio;
                    
                    // Add drop shadow for depth
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(this.x - this.width / 2 + 3, this.y - this.height / 2 + 3, this.width, this.height);
                    
                    // Create 3D gradient (lighter top-left, darker bottom-right)
                    const gradient = ctx.createLinearGradient(
                        this.x - this.width / 2, this.y - this.height / 2,
                        this.x + this.width / 2, this.y + this.height / 2
                    );
                    gradient.addColorStop(0, `hsl(${baseHue}, ${saturation}%, ${brightness + 15}%)`);
                    gradient.addColorStop(1, `hsl(${baseHue}, ${saturation}%, ${brightness - 10}%)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    
                    // Add brick pattern
                    ctx.strokeStyle = `hsl(${baseHue}, ${saturation}%, ${brightness - 15}%)`;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6;
                    
                    const brickHeight = 8; // Height of each brick row
                    const brickWidth = 16; // Width of individual bricks
                    const startX = this.x - this.width / 2;
                    const startY = this.y - this.height / 2;
                    
                    // Draw horizontal mortar lines
                    for (let y = brickHeight; y < this.height; y += brickHeight) {
                        ctx.beginPath();
                        ctx.moveTo(startX + 1, startY + y);
                        ctx.lineTo(startX + this.width - 1, startY + y);
                        ctx.stroke();
                    }
                    
                    // Draw vertical mortar lines (offset every other row for brick pattern)
                    let rowCount = 0;
                    for (let y = 0; y < this.height; y += brickHeight) {
                        const offset = (rowCount % 2) * (brickWidth / 2); // Offset every other row
                        for (let x = brickWidth + offset; x < this.width + offset; x += brickWidth) {
                            if (x >= 0 && x <= this.width) {
                                ctx.beginPath();
                                ctx.moveTo(startX + x, startY + y + 1);
                                ctx.lineTo(startX + x, startY + Math.min(y + brickHeight - 1, this.height - 1));
                                ctx.stroke();
                            }
                        }
                        rowCount++;
                    }
                    
                    ctx.globalAlpha = 1;
                    
                    // Add highlight on top edge
                    ctx.strokeStyle = `hsl(${baseHue}, ${saturation}%, ${brightness + 25}%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width / 2, this.y - this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y - this.height / 2);
                    ctx.stroke();
                    
                    // Add shadow on bottom edge
                    ctx.strokeStyle = `hsl(${baseHue}, ${saturation}%, ${brightness - 25}%)`;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width / 2, this.y + this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.stroke();
                    
                    // Main border
                    ctx.strokeStyle = `hsl(${baseHue}, ${saturation}%, ${brightness - 20}%)`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);

                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const currentCracks = this.maxHealth - this.health;
                    
                    if (currentCracks >= 1) {
                        ctx.moveTo(this.x - this.width / 2 + 5, this.y - this.height / 2 + 5);
                        ctx.lineTo(this.x + this.width / 2 - 5, this.y + this.height / 2 - 5);
                    }
                    if (currentCracks >= 2) {
                        ctx.moveTo(this.x + this.width / 2 - 5, this.y - this.height / 2 + 5);
                        ctx.lineTo(this.x - this.width / 2 + 5, this.y + this.height / 2 - 5);
                    }
                    ctx.stroke();
                } else if (this.type === 'indestructible') {
                    // Add drop shadow for depth
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(this.x - this.width / 2 + 4, this.y - this.height / 2 + 4, this.width, this.height);
                    
                    // Enhanced metallic gradient with more depth
                    const gradient = ctx.createLinearGradient(
                        this.x - this.width / 2, this.y - this.height / 2,
                        this.x + this.width / 2, this.y + this.height / 2
                    );
                    gradient.addColorStop(0, '#bdc3c7');
                    gradient.addColorStop(0.3, '#95a5a6');
                    gradient.addColorStop(0.7, '#7f8c8d');
                    gradient.addColorStop(1, '#636e72');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    
                    // Add metallic highlight on top and left edges
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width / 2, this.y - this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y - this.height / 2);
                    ctx.moveTo(this.x - this.width / 2, this.y - this.height / 2);
                    ctx.lineTo(this.x - this.width / 2, this.y + this.height / 2);
                    ctx.stroke();
                    
                    // Add dark shadow on bottom and right edges
                    ctx.strokeStyle = '#2d3436';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width / 2, this.y - this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.moveTo(this.x - this.width / 2, this.y + this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.stroke();
                    
                    // Main border
                    ctx.strokeStyle = '#636e72';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                } else if (this.type === 'moving') {
                    const glowColor = this.axis === 'horizontal' ? '#f39c12' : '#9b59b6';
                    const darkerGlow = this.axis === 'horizontal' ? '#d68910' : '#7d3c98';
                    const lighterGlow = this.axis === 'horizontal' ? '#f8c471' : '#bb8fce';
                    
                    // Add drop shadow with glow effect
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(this.x - this.width / 2 + 3, this.y - this.height / 2 + 3, this.width, this.height);
                    
                    // Create glowing gradient with depth
                    const gradient = ctx.createLinearGradient(
                        this.x - this.width / 2, this.y - this.height / 2,
                        this.x + this.width / 2, this.y + this.height / 2
                    );
                    gradient.addColorStop(0, lighterGlow);
                    gradient.addColorStop(0.5, glowColor);
                    gradient.addColorStop(1, darkerGlow);
                    
                    // Apply main glow effect
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    
                    // Add bright highlight on top edge
                    ctx.shadowBlur = 5;
                    ctx.strokeStyle = lighterGlow;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width / 2, this.y - this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y - this.height / 2);
                    ctx.stroke();
                    
                    // Main border with glow
                    ctx.strokeStyle = darkerGlow;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
                ctx.restore();
            }

            takeDamage() {
                if (this.type !== 'breakable') return;
                this.health--;
            }

            isDestroyed() {
                return this.type === 'breakable' && this.health <= 0;
            }

            update(allBarriers = []) {
                if (this.type !== 'moving' || this.isDestroyed() || this.direction === 0 || this.speed <= 0) return;
                
                // Calculate next position
                let nextX = this.x;
                let nextY = this.y;
                
                if (this.axis === 'horizontal') {
                    nextX += this.speed * this.direction;
                } else {
                    nextY += this.speed * this.direction;
                }
                
                // Check for collisions with other barriers
                let collision = false;
                for (const otherBarrier of allBarriers) {
                    if (otherBarrier === this || (otherBarrier.isDestroyed && otherBarrier.isDestroyed())) continue;
                    
                    // Check if next position would overlap with another barrier
                    if (nextX + this.width / 2 > otherBarrier.x - otherBarrier.width / 2 &&
                        nextX - this.width / 2 < otherBarrier.x + otherBarrier.width / 2 &&
                        nextY + this.height / 2 > otherBarrier.y - otherBarrier.height / 2 &&
                        nextY - this.height / 2 < otherBarrier.y + otherBarrier.height / 2) {
                        collision = true;
                        break;
                    }
                }
                
                if (collision) {
                    // Bounce back - reverse direction
                    this.direction *= -1;
                    return; // Don't move this frame
                }
                
                // Apply movement if no collision
                if (this.axis === 'horizontal') {
                    this.x = nextX;
                    const displacement = this.x - this.originX;
                    if (Math.abs(displacement) >= this.range) {
                        this.direction *= -1;
                        const sign = Math.sign(displacement) || this.direction;
                        this.x = this.originX + sign * this.range;
                    }
                    const minX = this.width / 2;
                    const maxX = canvas.width - this.width / 2;
                    if (this.x <= minX) {
                        this.x = minX;
                        this.direction = 1;
                    } else if (this.x >= maxX) {
                        this.x = maxX;
                        this.direction = -1;
                    }
                } else {
                    this.y = nextY;
                    const displacement = this.y - this.originY;
                    if (Math.abs(displacement) >= this.range) {
                        this.direction *= -1;
                        const sign = Math.sign(displacement) || this.direction;
                        this.y = this.originY + sign * this.range;
                    }
                    const minY = this.height / 2;
                    const maxY = canvas.height - this.height / 2;
                    if (this.y <= minY) {
                        this.y = minY;
                        this.direction = 1;
                    } else if (this.y >= maxY) {
                        this.y = maxY;
                        this.direction = -1;
                    }
                }
            }
        }

        // Environmental Hazard Classes
        class EnvironmentalHazard {
            constructor(x, y, width, height, type, options = {}) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.active = true;
                this.animationFrame = 0;
                
                // Type-specific properties
                if (type === 'lava') {
                    this.lastDamageTime = new Map(); // Track damage timing per tank
                } else if (type === 'teleporter') {
                    this.partner = options.partner || null;
                    this.cooldown = 0;
                    this.id = options.id || Math.random();
                } else if (type === 'conveyor') {
                    this.direction = options.direction || 0; // 0=right, 1=down, 2=left, 3=up
                    this.force = options.force || CONVEYOR_FORCE;
                } else if (type === 'ice') {
                    this.tanksOnIce = new Map(); // Track tanks currently on ice
                }
            }

            update() {
                this.animationFrame++;
                
                if (this.type === 'teleporter' && this.cooldown > 0) {
                    this.cooldown--;
                }
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                const centerX = this.x;
                const centerY = this.y;
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                if (this.type === 'lava') {
                    // Animated organic lava pool
                    const time = this.animationFrame * 0.1;
                    const bubbleOffset = Math.sin(time) * 3;
                    
                    // Create irregular lava pool shape using a path
                    ctx.beginPath();
                    
                    // Generate oval shape with slight irregularities
                    const points = 16; // More points for smoother oval
                    
                    for (let i = 0; i <= points; i++) {
                        const angle = (i / points) * Math.PI * 2;
                        
                        // Create elliptical shape using width and height
                        const baseRadiusX = halfWidth;
                        const baseRadiusY = halfHeight;
                        
                        // Add some randomness for natural variation (but consistent per pool)
                        const seed = (this.x + this.y) * 0.001;
                        const variation = 0.85 + 0.15 * Math.sin(seed * 7 + i * 1.5); // Slight variation 0.85-1.0
                        
                        // Calculate ellipse radius at this angle
                        const radiusX = baseRadiusX * variation;
                        const radiusY = baseRadiusY * variation;
                        
                        // Add gentle wobble animation for liquid effect
                        const wobble = Math.sin(time * 1.5 + i * 0.4) * 1.5;
                        
                        const x = centerX + Math.cos(angle) * (radiusX + wobble);
                        const y = centerY + Math.sin(angle) * (radiusY + wobble);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            // Use smooth curves for oval shape
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    
                    // Base lava gradient
                    const gradientRadius = Math.max(halfWidth, halfHeight);
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, gradientRadius);
                    gradient.addColorStop(0, '#FF4500');
                    gradient.addColorStop(0.6, '#FF6347');
                    gradient.addColorStop(1, '#8B0000');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowColor = '#FF4500';
                    ctx.shadowBlur = 15;
                    ctx.globalAlpha = 0.3;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    
                    // Animated bubbles (adjusted for organic shape)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(centerX + bubbleOffset * 0.5, centerY - bubbleOffset * 0.3, 4, 0, Math.PI * 2);
                    ctx.arc(centerX - bubbleOffset * 0.4, centerY + bubbleOffset * 0.6, 3, 0, Math.PI * 2);
                    ctx.arc(centerX + bubbleOffset * 0.2, centerY + bubbleOffset * 0.2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Debug: Show collision area outline when debug mode is enabled
                    if (typeof showDebugInfo !== 'undefined' && showDebugInfo) {
                        ctx.strokeStyle = '#00FF00';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.stroke(); // Stroke the same organic path we created
                        ctx.globalAlpha = 1;
                    }
                    
                } else if (this.type === 'teleporter') {
                    // Animated teleporter portal
                    const time = this.animationFrame * 0.08;
                    const pulseSize = 5 + Math.sin(time) * 3;
                    const isOnCooldown = this.cooldown > 0;
                    
                    // Portal base
                    const portalGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, halfWidth);
                    if (isOnCooldown) {
                        portalGradient.addColorStop(0, '#666666');
                        portalGradient.addColorStop(1, '#333333');
                    } else {
                        portalGradient.addColorStop(0, '#00FFFF');
                        portalGradient.addColorStop(0.5, '#0080FF');
                        portalGradient.addColorStop(1, '#000080');
                    }
                    
                    ctx.fillStyle = portalGradient;
                    ctx.fillRect(centerX - halfWidth, centerY - halfHeight, this.width, this.height);
                    
                    // Animated portal ring
                    if (!isOnCooldown) {
                        ctx.strokeStyle = '#00FFFF';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, halfWidth - pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                } else if (this.type === 'conveyor') {
                    // Conveyor belt with subtle moving texture
                    const time = this.animationFrame * 0.03;
                    
                    // Base conveyor belt color with gradient
                    const beltGradient = ctx.createLinearGradient(centerX - halfWidth, centerY - halfHeight, centerX + halfWidth, centerY + halfHeight);
                    beltGradient.addColorStop(0, '#5a5a5a');
                    beltGradient.addColorStop(0.5, '#696969');
                    beltGradient.addColorStop(1, '#4a4a4a');
                    ctx.fillStyle = beltGradient;
                    ctx.fillRect(centerX - halfWidth, centerY - halfHeight, this.width, this.height);
                    
                    // Belt edges/rails
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(centerX - halfWidth, centerY - halfHeight, this.width, this.height);
                    
                    // Moving belt texture pattern
                    ctx.strokeStyle = '#808080';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    
                    const patternSpacing = 8;
                    const offset = (time * 10) % patternSpacing;
                    
                    if (this.direction === 0 || this.direction === 2) { // Horizontal
                        // Moving horizontal lines to simulate belt texture
                        for (let x = offset - patternSpacing; x < this.width + patternSpacing; x += patternSpacing) {
                            const lineX = centerX - halfWidth + x;
                            if (lineX >= centerX - halfWidth + 2 && lineX <= centerX + halfWidth - 2) {
                                ctx.beginPath();
                                ctx.moveTo(lineX, centerY - halfHeight + 2);
                                ctx.lineTo(lineX, centerY + halfHeight - 2);
                                ctx.stroke();
                            }
                        }
                        
                        // Direction indicator - subtle chevron pattern
                        ctx.globalAlpha = 0.6;
                        ctx.strokeStyle = this.direction === 0 ? '#90EE90' : '#FFB6C1';
                        ctx.lineWidth = 2;
                        const chevronY = centerY;
                        const chevronSpacing = 20;
                        const chevronOffset = (time * 8) % chevronSpacing;
                        
                        for (let x = chevronOffset - chevronSpacing; x < this.width + chevronSpacing; x += chevronSpacing) {
                            const chevronX = centerX - halfWidth + x;
                            const dir = this.direction === 0 ? 1 : -1;
                            
                            if (chevronX >= centerX - halfWidth + 8 && chevronX <= centerX + halfWidth - 8) {
                                ctx.beginPath();
                                ctx.moveTo(chevronX - 4 * dir, chevronY - 3);
                                ctx.lineTo(chevronX + 2 * dir, chevronY);
                                ctx.lineTo(chevronX - 4 * dir, chevronY + 3);
                                ctx.stroke();
                            }
                        }
                        
                    } else { // Vertical
                        // Moving vertical lines to simulate belt texture
                        for (let y = offset - patternSpacing; y < this.height + patternSpacing; y += patternSpacing) {
                            const lineY = centerY - halfHeight + y;
                            if (lineY >= centerY - halfHeight + 2 && lineY <= centerY + halfHeight - 2) {
                                ctx.beginPath();
                                ctx.moveTo(centerX - halfWidth + 2, lineY);
                                ctx.lineTo(centerX + halfWidth - 2, lineY);
                                ctx.stroke();
                            }
                        }
                        
                        // Direction indicator - subtle chevron pattern
                        ctx.globalAlpha = 0.6;
                        ctx.strokeStyle = this.direction === 1 ? '#90EE90' : '#FFB6C1';
                        ctx.lineWidth = 2;
                        const chevronX = centerX;
                        const chevronSpacing = 20;
                        const chevronOffset = (time * 8) % chevronSpacing;
                        
                        for (let y = chevronOffset - chevronSpacing; y < this.height + chevronSpacing; y += chevronSpacing) {
                            const chevronY = centerY - halfHeight + y;
                            const dir = this.direction === 1 ? 1 : -1;
                            
                            if (chevronY >= centerY - halfHeight + 8 && chevronY <= centerY + halfHeight - 8) {
                                ctx.beginPath();
                                ctx.moveTo(chevronX - 3, chevronY - 4 * dir);
                                ctx.lineTo(chevronX, chevronY + 2 * dir);
                                ctx.lineTo(chevronX + 3, chevronY - 4 * dir);
                                ctx.stroke();
                            }
                        }
                    }
                    
                    ctx.globalAlpha = 1;
                } else if (this.type === 'ice') {
                    // Animated organic ice patch (translucent to show ground below)
                    const time = this.animationFrame * 0.05;
                    
                    // Create irregular ice patch shape using a path
                    ctx.beginPath();
                    
                    // Generate organic ice shape with multiple control points
                    const points = 12; // More points for smoother ice shape
                    
                    for (let i = 0; i <= points; i++) {
                        const angle = (i / points) * Math.PI * 2;
                        
                        // Create elliptical base with ice-like variation
                        const baseRadiusX = halfWidth;
                        const baseRadiusY = halfHeight;
                        
                        // Add crystalline variation for ice (more angular than lava)
                        const seed = (this.x + this.y) * 0.001;
                        const variation = 0.8 + 0.2 * Math.cos(seed * 9 + i * 1.8); // More angular variation
                        
                        // Calculate ellipse radius at this angle
                        const radiusX = baseRadiusX * variation;
                        const radiusY = baseRadiusY * variation;
                        
                        // Add very gentle animation for frozen effect
                        const wobble = Math.sin(time * 0.8 + i * 0.6) * 0.8; // Much less wobble than lava
                        
                        const x = centerX + Math.cos(angle) * (radiusX + wobble);
                        const y = centerY + Math.sin(angle) * (radiusY + wobble);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    
                    // Make ice translucent so ground shows through
                    ctx.globalAlpha = 0.6;
                    
                    // Base ice gradient
                    const gradientRadius = Math.max(halfWidth, halfHeight);
                    const iceGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, gradientRadius);
                    iceGradient.addColorStop(0, '#E0F6FF');
                    iceGradient.addColorStop(0.6, '#B0E0E6');
                    iceGradient.addColorStop(1, '#87CEEB');
                    
                    ctx.fillStyle = iceGradient;
                    ctx.fill();
                    
                    // Ice crystals/sparkles (more opaque than base ice)
                    ctx.globalAlpha = 0.8;
                    ctx.fillStyle = '#FFFFFF';
                    const sparkleCount = 8;
                    for (let i = 0; i < sparkleCount; i++) {
                        const angle = (i / sparkleCount) * Math.PI * 2 + time;
                        const radius = Math.min(halfWidth, halfHeight) * 0.6;
                        const sparkleX = centerX + Math.cos(angle) * radius * (0.5 + 0.5 * Math.sin(time + i));
                        const sparkleY = centerY + Math.sin(angle) * radius * (0.5 + 0.5 * Math.cos(time + i));
                        const sparkleSize = 1 + Math.sin(time * 3 + i) * 0.5;
                        
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Frost effect around edges (outline the organic shape)
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;
                    ctx.stroke(); // Stroke the organic path we created
                    
                    // Debug: Show collision area outline when debug mode is enabled
                    if (typeof showDebugInfo !== 'undefined' && showDebugInfo) {
                        ctx.strokeStyle = '#00FFFF';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.stroke();
                    }
                    
                    // Reset alpha for other elements
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
            }

            // Check if a tank overlaps with this hazard
            overlapsWithTank(tank) {
                if (this.type === 'lava') {
                    // For lava, check if tank center is inside the organic shape
                    return this.isPointInLavaShape(tank.x, tank.y);
                } else if (this.type === 'ice') {
                    // For ice, check if tank center is inside the organic shape
                    return this.isPointInIceShape(tank.x, tank.y);
                }
                
                // For other hazards, use rectangular collision
                return tank.x + TANK_COLLISION_RADIUS > this.x - this.width / 2 &&
                       tank.x - TANK_COLLISION_RADIUS < this.x + this.width / 2 &&
                       tank.y + TANK_COLLISION_RADIUS > this.y - this.height / 2 &&
                       tank.y - TANK_COLLISION_RADIUS < this.y + this.height / 2;
            }
            
            // Check if a point is inside the oval lava shape
            isPointInLavaShape(x, y) {
                if (this.type !== 'lava') return false;
                
                const centerX = this.x;
                const centerY = this.y;
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                
                // Calculate relative position from center
                const dx = x - centerX;
                const dy = y - centerY;
                
                // Use ellipse equation with slight variation for natural edges
                const seed = (this.x + this.y) * 0.001;
                const angle = Math.atan2(dy, dx);
                
                // Add the same variation as in the drawing
                const variation = 0.85 + 0.15 * Math.sin(seed * 7 + angle * 8); // Match drawing variation
                
                // Ellipse equation: (x/a)² + (y/b)² <= 1
                const normalizedX = dx / (halfWidth * variation);
                const normalizedY = dy / (halfHeight * variation);
                const ellipseValue = (normalizedX * normalizedX) + (normalizedY * normalizedY);
                
                // Point is inside if ellipse value is less than or equal to 1
                return ellipseValue <= 1.0;
            }
            
            // Check if a point is inside the organic ice shape
            isPointInIceShape(x, y) {
                if (this.type !== 'ice') return false;
                
                const centerX = this.x;
                const centerY = this.y;
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                
                // Calculate relative position from center
                const dx = x - centerX;
                const dy = y - centerY;
                
                // Use ellipse equation with crystalline variation for ice
                const seed = (this.x + this.y) * 0.001;
                const angle = Math.atan2(dy, dx);
                
                // Add the same variation as in the drawing (more angular for ice)
                const variation = 0.8 + 0.2 * Math.cos(seed * 9 + angle * 6); // Match drawing variation
                
                // Ellipse equation: (x/a)² + (y/b)² <= 1
                const normalizedX = dx / (halfWidth * variation);
                const normalizedY = dy / (halfHeight * variation);
                const ellipseValue = (normalizedX * normalizedX) + (normalizedY * normalizedY);
                
                // Point is inside if ellipse value is less than or equal to 1
                return ellipseValue <= 1.0;
            }

            // Check if a bullet overlaps with this hazard
            overlapsWithBullet(bullet) {
                return bullet.x > this.x - this.width / 2 &&
                       bullet.x < this.x + this.width / 2 &&
                       bullet.y > this.y - this.height / 2 &&
                       bullet.y < this.y + this.height / 2;
            }
        }

        class Bullet {
            constructor(x, y, angle, color) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.angle = angle;
                this.color = color;
                this.speed = BULLET_SPEED;
                this.hasBounced = false;
                
                // Power-up properties
                this.bounces = 0; // Number of bounces remaining (0 = normal bullet)
                this.pierce = false; // Can pierce through barriers
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = TANK_SIZE * 1.5; 
                this.lifespan = 60;
                this.frame = 0;
                this.particles = [];
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        angle: Math.random() * Math.PI * 2,
                        speed: Math.random() * 3 + 1,
                        size: Math.random() * 5 + 2,
                        x: 0,
                        y: 0
                    });
                }
            }

            update() {
                this.frame++;
                if (this.frame > this.lifespan) return;
                this.radius = (this.frame / this.lifespan) * this.maxRadius;
                this.particles.forEach(p => {
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                    p.speed *= 0.95;
                });
            }

            draw() {
                if (this.frame > this.lifespan) return;
                const alpha = 1 - (this.frame / this.lifespan);
                ctx.save();
                ctx.translate(this.x, this.y);
                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, ${Math.floor(200 * alpha)}, 0, ${alpha})`;
                    ctx.fill();
                });
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 165, 0, ${alpha * 0.8})`;
                ctx.shadowBlur = 20 * alpha;
                ctx.shadowColor = `rgba(255, 255, 0, ${alpha})`;
                ctx.fill();
                ctx.restore();
            }

            isFinished() {
                return this.frame > this.lifespan;
            }
        }
        
        class TeleportEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = TANK_SIZE;
                this.lifespan = 30;
                this.frame = 0;
            }

            update() {
                this.frame++;
                this.radius = (this.frame / this.lifespan) * this.maxRadius;
            }

            draw() {
                if (this.frame > this.lifespan) return;
                const alpha = 1 - (this.frame / this.lifespan);
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Teleport ring effect
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 15 * alpha;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner sparkles
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + this.frame * 0.2;
                    const x = Math.cos(angle) * this.radius * 0.7;
                    const y = Math.sin(angle) * this.radius * 0.7;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            isFinished() {
                return this.frame > this.lifespan;
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = 25;
                this.collected = false;
                this.animationFrame = 0;
                this.duration = this.getPowerUpDuration();
                
                // Visual properties
                this.color = this.getPowerUpColor();
                this.symbol = this.getPowerUpSymbol();
            }

            getPowerUpDuration() {
                switch(this.type) {
                    case 'spread': return 10000; // 10 seconds
                    case 'rapid': return 8000;   // 8 seconds
                    case 'bounce': return 12000; // 12 seconds
                    case 'pierce': return 15000; // 15 seconds
                    default: return 10000;
                }
            }

            getPowerUpColor() {
                switch(this.type) {
                    case 'spread': return '#ff6b35'; // Orange
                    case 'rapid': return '#f7931e';  // Yellow-orange
                    case 'bounce': return '#9b59b6'; // Purple
                    case 'pierce': return '#e74c3c'; // Red
                    default: return '#95a5a6';
                }
            }

            getPowerUpSymbol() {
                switch(this.type) {
                    case 'spread': return '◊';  // Diamond for spread shot
                    case 'rapid': return '≡';   // Triple lines for rapid fire
                    case 'bounce': return '◈';  // Diamond with lines for bounce
                    case 'pierce': return '→';  // Arrow for pierce shot
                    default: return '?';
                }
            }

            update() {
                this.animationFrame++;
            }

            draw() {
                if (this.collected) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Floating animation
                const floatOffset = Math.sin(this.animationFrame * 0.1) * 3;
                ctx.translate(0, floatOffset);
                
                // Rotation animation
                ctx.rotate(this.animationFrame * 0.02);
                
                // Glow effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                
                // Outer ring
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner filled circle
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Symbol
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, 0, 0);
                
                // Pulsing outer glow
                const pulseAlpha = 0.3 + 0.3 * Math.sin(this.animationFrame * 0.15);
                ctx.globalAlpha = pulseAlpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }

            checkCollision(tank) {
                if (this.collected) return false;
                const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
                return distance < (this.size + TANK_COLLISION_RADIUS);
            }

            collect() {
                this.collected = true;
                return {
                    type: this.type,
                    duration: this.duration
                };
            }
        }

        class Flag {
            constructor(x, y, team, baseX, baseY) {
                this.x = x;
                this.y = y;
                this.baseX = baseX; // Home base position
                this.baseY = baseY;
                this.team = team; // 'red' or 'blue'
                this.size = 30;
                this.carriedBy = null; // Tank carrying the flag
                this.isAtBase = true;
                this.animationFrame = 0;
                this.dropTime = 0; // When flag was dropped
                this.returnDelay = 10000; // 10 seconds to auto-return
                
                // Visual properties
                this.color = team === 'red' ? '#e74c3c' : '#3498db';
                this.lightColor = team === 'red' ? '#ff6b6b' : '#74b9ff';
            }

            update() {
                this.animationFrame++;
                
                // If flag is carried, move with tank
                if (this.carriedBy && !this.carriedBy.isHit) {
                    this.x = this.carriedBy.x;
                    this.y = this.carriedBy.y - this.size;
                } else if (this.carriedBy) {
                    // Tank was destroyed, drop flag
                    this.drop(this.carriedBy.x, this.carriedBy.y);
                }
                
                // Auto-return dropped flag after delay
                if (!this.isAtBase && !this.carriedBy) {
                    const now = Date.now();
                    if (now - this.dropTime > this.returnDelay) {
                        this.returnToBase();
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Flag pole
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -this.size);
                ctx.stroke();
                
                // Flag animation
                const waveOffset = Math.sin(this.animationFrame * 0.1) * 3;
                
                // Flag fabric
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(20 + waveOffset, -this.size + 5);
                ctx.lineTo(18 + waveOffset * 0.8, -this.size + 15);
                ctx.lineTo(0, -this.size + 10);
                ctx.closePath();
                ctx.fill();
                
                // Flag highlight
                ctx.fillStyle = this.lightColor;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(15 + waveOffset * 0.7, -this.size + 3);
                ctx.lineTo(13 + waveOffset * 0.5, -this.size + 8);
                ctx.lineTo(0, -this.size + 5);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Status indicators
                if (this.carriedBy) {
                    // Carried flag glow
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, -10, this.size * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (!this.isAtBase) {
                    // Dropped flag pulse
                    const pulse = 0.5 + 0.5 * Math.sin(this.animationFrame * 0.2);
                    ctx.globalAlpha = pulse;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
            }

            checkCollision(tank) {
                const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
                return distance < (this.size + TANK_COLLISION_RADIUS);
            }

            pickup(tank) {
                if (this.carriedBy || tank.isHit) return false;
                
                // Can't pick up own flag unless it's returning it to base
                if (this.team === (tank === player1 ? 'red' : 'blue')) {
                    if (!this.isAtBase) {
                        // Returning own flag to base
                        this.returnToBase();
                        return 'returned';
                    }
                    return false;
                }
                
                // Enemy picking up flag
                this.carriedBy = tank;
                this.isAtBase = false;
                return 'captured';
            }

            drop(x, y) {
                this.carriedBy = null;
                this.x = x;
                this.y = y;
                this.isAtBase = false;
                this.dropTime = Date.now();
            }

            returnToBase() {
                this.x = this.baseX;
                this.y = this.baseY;
                this.carriedBy = null;
                this.isAtBase = true;
                this.dropTime = 0;
            }

            isCarriedByTeam(team) {
                if (!this.carriedBy) return false;
                const carrierTeam = this.carriedBy === player1 ? 'red' : 'blue';
                return carrierTeam === team;
            }
        }

        class FlagBase {
            constructor(x, y, team) {
                this.x = x;
                this.y = y;
                this.team = team;
                this.radius = 50;
                this.animationFrame = 0;
                this.color = team === 'red' ? '#e74c3c' : '#3498db';
                this.lightColor = team === 'red' ? '#ff6b6b' : '#74b9ff';
            }

            update() {
                this.animationFrame++;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Base circle with pulsing effect
                const pulse = 0.8 + 0.2 * Math.sin(this.animationFrame * 0.05);
                ctx.globalAlpha = 0.3 * pulse;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Base ring
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner ring
                ctx.globalAlpha = 0.8;
                ctx.strokeStyle = this.lightColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();
                
                // Team indicator
                ctx.globalAlpha = 1;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.team.toUpperCase() + ' BASE', 0, 0);
                
                ctx.restore();
            }

            checkCollision(tank) {
                const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
                return distance < this.radius;
            }
        }
        
        let player1, player2;

        function initializeTanks() {
            player1 = new Tank(TANK_START_MARGIN, canvas.height / 2, '#e74c3c', '#c0392b');
            player1.angle = 0;

            if (gameMode === 'twoPlayer') {
                player2 = new Tank(canvas.width - TANK_START_MARGIN, canvas.height / 2, '#3498db', '#2980b9');
            } else if (gameMode === 'vsAI') {
                player2 = new AITank(canvas.width - TANK_START_MARGIN, canvas.height / 2, '#3498db', '#2980b9');
            } else if (gameMode === 'captureTheFlag') {
                player2 = new Tank(canvas.width - TANK_START_MARGIN, canvas.height / 2, '#3498db', '#2980b9');
                
                // Initialize CTF elements
                const baseY = canvas.height / 2;
                redBase = new FlagBase(80, baseY, 'red');
                blueBase = new FlagBase(canvas.width - 80, baseY, 'blue');
                
                redFlag = new Flag(80, baseY, 'red', 80, baseY);
                blueFlag = new Flag(canvas.width - 80, baseY, 'blue', canvas.width - 80, baseY);
            }
            
            // Ensure player2 is properly oriented regardless of game mode
            if (player2) {
                player2.angle = Math.PI;
            }
        }

        function updateScoreboard() {
            player1ScoreDisplay.textContent = player1Score;
            player2ScoreDisplay.textContent = player2Score;
        }

        function bounceBulletOffBarrier(bullet, barrier) {
            const dx = bullet.x - barrier.x;
            const dy = bullet.y - barrier.y;
            const halfWidth = barrier.width / 2;
            const halfHeight = barrier.height / 2;
            const overlapX = halfWidth + bullet.radius - Math.abs(dx);
            const overlapY = halfHeight + bullet.radius - Math.abs(dy);

            if (overlapX < overlapY) {
                const approach = Math.cos(bullet.angle);
                bullet.angle = Math.PI - bullet.angle;
                const direction = dx === 0 ? (approach >= 0 ? 1 : -1) : (dx > 0 ? 1 : -1);
                bullet.x = barrier.x + direction * (halfWidth + bullet.radius + 0.1);
            } else {
                const approach = Math.sin(bullet.angle);
                bullet.angle = -bullet.angle;
                const direction = dy === 0 ? (approach >= 0 ? 1 : -1) : (dy > 0 ? 1 : -1);
                bullet.y = barrier.y + direction * (halfHeight + bullet.radius + 0.1);
            }
        }
        
        function generateBarriers() {
            barriers.length = 0;
            hazards.length = 0;
            const barrierSize = BARRIER_SIZE; // Grid cell size for placement
            // Remove padding - barriers now fill the entire grid square
            const barrierInteriorSize = barrierSize; // Full size instead of padded size
            const gridCols = Math.floor((canvas.width / 2) / barrierSize);
            const gridRows = Math.floor(canvas.height / barrierSize);
            const occupied = new Set();
            const safeZoneCols = Math.ceil((TANK_START_MARGIN + TANK_COLLISION_RADIUS) / barrierSize);

            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const key = `${col},${row}`;
                    if (occupied.has(key) || col < safeZoneCols) continue;

                    if (Math.random() < BARRIER_SPAWN_CHANCE) {
                        const typeRoll = Math.random();
                        let barrierType = 'breakable';
                        if (typeRoll < BARRIER_TYPE_CHANCES.indestructible) {
                            barrierType = 'indestructible';
                        } else if (typeRoll < BARRIER_TYPE_CHANCES.indestructible + BARRIER_TYPE_CHANCES.moving) {
                            barrierType = 'moving';
                        }

                        let wallLength = Math.floor(Math.random() * (BARRIER_MAX_LENGTH - BARRIER_MIN_LENGTH + 1)) + BARRIER_MIN_LENGTH;
                        let direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                        if (barrierType === 'moving') {
                            wallLength = 1;
                        }

                        let currentCol = col;
                        let currentRow = row;

                        for (let i = 0; i < wallLength; i++) {
                            const currentKey = `${currentCol},${currentRow}`;
                            
                            if ((direction === 'horizontal' && currentCol >= gridCols) || (direction === 'vertical' && currentRow >= gridRows) || occupied.has(currentKey)) break;
                            
                        const x = currentCol * barrierSize + barrierSize / 2;
                        const y = currentRow * barrierSize + barrierSize / 2;
                        
                        // Generate all random values once for perfect symmetry
                        const randomHealth = Math.floor(Math.random() * 3) + 1;
                        const randomAxis = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                        const randomSpeed = MOVING_BARRIER_SPEED + Math.random() * 0.6;
                        const randomDirection = Math.random() < 0.5 ? 1 : -1;
                        
                        const baseOptions = { type: barrierType };
                        if (barrierType === 'breakable') {
                            baseOptions.health = randomHealth;
                        } else if (barrierType === 'moving') {
                            baseOptions.axis = randomAxis;
                            baseOptions.speed = randomSpeed;
                            baseOptions.range = barrierSize * MOVING_BARRIER_RANGE_MULTIPLIER;
                            baseOptions.initialDirection = randomDirection;
                            baseOptions.health = Infinity;
                        }
                        
                        occupied.add(currentKey);
                        const mirrorOptions = Object.assign({}, baseOptions);
                        if (baseOptions.type === 'moving') {
                            mirrorOptions.initialDirection = -randomDirection; // Use the same random value, just negate it
                        }
                        barriers.push(new Barrier(x, y, barrierInteriorSize, barrierInteriorSize, Object.assign({}, baseOptions)));
                        barriers.push(new Barrier(canvas.width - x, y, barrierInteriorSize, barrierInteriorSize, mirrorOptions));                            if (direction === 'horizontal') currentCol++;
                            else currentRow++;
                        }
                    }
                }
            }
            
            // Generate environmental hazards
            const teleporterPairs = [];
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const key = `${col},${row}`;
                    if (occupied.has(key) || col < safeZoneCols) continue;

                    if (Math.random() < HAZARD_SPAWN_CHANCE) {
                        const typeRoll = Math.random();
                        let hazardType = 'lava';
                        
                        if (typeRoll < HAZARD_TYPE_CHANCES.lava) {
                            hazardType = 'lava';
                        } else if (typeRoll < HAZARD_TYPE_CHANCES.lava + HAZARD_TYPE_CHANCES.teleporter) {
                            hazardType = 'teleporter';
                        } else if (typeRoll < HAZARD_TYPE_CHANCES.lava + HAZARD_TYPE_CHANCES.teleporter + HAZARD_TYPE_CHANCES.conveyor) {
                            hazardType = 'conveyor';
                        } else {
                            hazardType = 'ice';
                        }
                        
                        const x = col * barrierSize + barrierSize / 2;
                        const y = row * barrierSize + barrierSize / 2;
                        
                        occupied.add(key);
                        
                        if (hazardType === 'teleporter') {
                            // Create teleporter pairs
                            const teleporterId = Math.random();
                            const teleporter1 = new EnvironmentalHazard(x, y, barrierInteriorSize, barrierInteriorSize, 'teleporter', { id: teleporterId });
                            const teleporter2 = new EnvironmentalHazard(canvas.width - x, y, barrierInteriorSize, barrierInteriorSize, 'teleporter', { id: teleporterId });
                            
                            teleporter1.partner = teleporter2;
                            teleporter2.partner = teleporter1;
                            
                            hazards.push(teleporter1, teleporter2);
                        } else if (hazardType === 'conveyor') {
                            const direction = Math.floor(Math.random() * 4); // 0=right, 1=down, 2=left, 3=up
                            hazards.push(new EnvironmentalHazard(x, y, barrierInteriorSize, barrierInteriorSize, 'conveyor', { direction }));
                            hazards.push(new EnvironmentalHazard(canvas.width - x, y, barrierInteriorSize, barrierInteriorSize, 'conveyor', { direction: (direction + 2) % 4 })); // Mirror direction
                        } else if (hazardType === 'ice') {
                            // Ice patches - create clusters of 2-4 adjacent ice blocks
                            const clusterSize = Math.floor(Math.random() * 3) + 2; // 2-4 blocks
                            const icePositions = [{ col, row }]; // Start with current position
                            
                            // Try to add adjacent ice blocks to create a cluster
                            for (let i = 1; i < clusterSize; i++) {
                                const directions = [
                                    { dc: 1, dr: 0 },  // Right
                                    { dc: 0, dr: 1 },  // Down
                                    { dc: -1, dr: 0 }, // Left
                                    { dc: 0, dr: -1 }  // Up
                                ];
                                
                                // Shuffle directions for random cluster shapes
                                for (let j = directions.length - 1; j > 0; j--) {
                                    const k = Math.floor(Math.random() * (j + 1));
                                    [directions[j], directions[k]] = [directions[k], directions[j]];
                                }
                                
                                let placed = false;
                                for (const dir of directions) {
                                    // Try to place adjacent to an existing ice block in the cluster
                                    for (const pos of icePositions) {
                                        const newCol = pos.col + dir.dc;
                                        const newRow = pos.row + dir.dr;
                                        const newKey = `${newCol},${newRow}`;
                                        
                                        // Check if position is valid and not occupied
                                        if (newCol >= safeZoneCols && newCol < gridCols && 
                                            newRow >= 0 && newRow < gridRows && 
                                            !occupied.has(newKey) &&
                                            !icePositions.some(p => p.col === newCol && p.row === newRow)) {
                                            
                                            icePositions.push({ col: newCol, row: newRow });
                                            placed = true;
                                            break;
                                        }
                                    }
                                    if (placed) break;
                                }
                                if (!placed) break; // Stop if we can't place more ice blocks
                            }
                            
                            // Create single organic ice patch instead of multiple grid squares
                            // Generate all random values once for perfect symmetry
                            const iceSize = 50 + Math.random() * 50; // Random size between 50-100 pixels
                            const iceWidthVariation = (Math.random() - 0.5) * 25;
                            const iceHeightVariation = (Math.random() - 0.5) * 25;
                            const iceWidth = iceSize + iceWidthVariation; // Irregular width
                            const iceHeight = iceSize + iceHeightVariation; // Irregular height
                            
                            // Add some random offset from grid alignment
                            const offsetX = (Math.random() - 0.5) * (barrierSize * 0.3);
                            const offsetY = (Math.random() - 0.5) * (barrierSize * 0.3);
                            const iceX = x + offsetX;
                            const iceY = y + offsetY;
                            
                            // Ensure ice patches don't go outside canvas bounds
                            const finalX = Math.max(iceWidth/2 + 10, Math.min(canvas.width/2 - iceWidth/2 - 10, iceX));
                            const finalY = Math.max(iceHeight/2 + 10, Math.min(canvas.height - iceHeight/2 - 10, iceY));
                            
                            hazards.push(new EnvironmentalHazard(finalX, finalY, iceWidth, iceHeight, 'ice'));
                            
                            // Create perfectly mirrored ice patch on the other side
                            const mirrorIceWidth = iceSize + iceWidthVariation; // Use same variation
                            const mirrorIceHeight = iceSize + iceHeightVariation; // Use same variation
                            const mirrorX = canvas.width - finalX;
                            const mirrorY = y + offsetY; // Use same Y offset
                            const finalMirrorY = Math.max(mirrorIceHeight/2 + 10, Math.min(canvas.height - mirrorIceHeight/2 - 10, mirrorY));
                            
                            hazards.push(new EnvironmentalHazard(mirrorX, finalMirrorY, mirrorIceWidth, mirrorIceHeight, 'ice'));
                        } else {
                            // Create larger irregular lava pool with random shape
                            // Generate all random values once for perfect symmetry
                            const lavaSize = 60 + Math.random() * 60; // Random size between 60-120 pixels (bigger than grid)
                            const lavaWidthVariation = (Math.random() - 0.5) * 30;
                            const lavaHeightVariation = (Math.random() - 0.5) * 30;
                            const lavaWidth = lavaSize + lavaWidthVariation; // More irregular width
                            const lavaHeight = lavaSize + lavaHeightVariation; // More irregular height
                            
                            // Add some random offset from grid alignment for more natural placement
                            const offsetX = (Math.random() - 0.5) * (barrierSize * 0.3);
                            const offsetY = (Math.random() - 0.5) * (barrierSize * 0.3);
                            const lavaX = x + offsetX;
                            const lavaY = y + offsetY;
                            
                            // Ensure lava pools don't go outside canvas bounds
                            const finalX = Math.max(lavaWidth/2 + 10, Math.min(canvas.width/2 - lavaWidth/2 - 10, lavaX));
                            const finalY = Math.max(lavaHeight/2 + 10, Math.min(canvas.height - lavaHeight/2 - 10, lavaY));
                            
                            hazards.push(new EnvironmentalHazard(finalX, finalY, lavaWidth, lavaHeight, 'lava'));
                            
                            // Create perfectly mirrored lava pool on the other side
                            const mirrorLavaWidth = lavaSize + lavaWidthVariation; // Use same variations
                            const mirrorLavaHeight = lavaSize + lavaHeightVariation; // Use same variations
                            const mirrorX = canvas.width - finalX;
                            const mirrorY = y + offsetY; // Use same Y offset
                            const finalMirrorY = Math.max(mirrorLavaHeight/2 + 10, Math.min(canvas.height - mirrorLavaHeight/2 - 10, mirrorY));
                            
                            hazards.push(new EnvironmentalHazard(mirrorX, finalMirrorY, mirrorLavaWidth, mirrorLavaHeight, 'lava'));
                        }
                    }
                }
            }
        }

        function spawnPowerUp() {
            // Don't spawn if we have too many power-ups already
            if (powerUps.filter(p => !p.collected).length >= POWERUP_MAX_ACTIVE) return;
            
            // Find a valid spawn location
            for (let attempts = 0; attempts < POWERUP_SPAWN_ATTEMPTS; attempts++) {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = 100 + Math.random() * (canvas.height - 200);
                
                // Check if location conflicts with barriers
                let validLocation = true;
                for (const barrier of barriers) {
                    if (!barrier.isDestroyed()) {
                        const dx = Math.abs(x - barrier.x);
                        const dy = Math.abs(y - barrier.y);
                        if (dx < barrier.width/2 + 40 && dy < barrier.height/2 + 40) {
                            validLocation = false;
                            break;
                        }
                    }
                }
                
                // Check if location conflicts with hazards
                for (const hazard of hazards) {
                    const distance = Math.hypot(x - hazard.x, y - hazard.y);
                    if (distance < hazard.width/2 + 40) {
                        validLocation = false;
                        break;
                    }
                }
                
                // Check if location is too close to tanks
                if (player1 && Math.hypot(x - player1.x, y - player1.y) < 80) validLocation = false;
                if (player2 && Math.hypot(x - player2.x, y - player2.y) < 80) validLocation = false;
                
                if (validLocation) {
                    const randomType = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
                    powerUps.push(new PowerUp(x, y, randomType));
                    break;
                }
            }
        }

        function destroyTank(tank, isPlayer1Tank) {
            if (tank.isHit) return;
            
            // In CTF mode, don't award kill points, only flag captures count
            if (gameMode !== 'captureTheFlag') {
                if (isPlayer1Tank) {
                    player2Score++;
                } else {
                    player1Score++;
                }
                updateScoreboard();
            }
            
            // Drop any carried flags in CTF mode
            if (gameMode === 'captureTheFlag') {
                if (redFlag && redFlag.carriedBy === tank) {
                    redFlag.drop(tank.x, tank.y);
                }
                if (blueFlag && blueFlag.carriedBy === tank) {
                    blueFlag.drop(tank.x, tank.y);
                }
            }
            
            const explosion = new Explosion(tank.x, tank.y);
            explosions.push(explosion);
            playExplosionSound();
            tank.isHit = true;
            const respawnDelay = explosion.lifespan * (1000 / 60);
            setTimeout(() => resetTank(tank, isPlayer1Tank), respawnDelay);
        }

        function tankOverlapsBarrier(tank, barrier) {
            return tank.x + TANK_COLLISION_RADIUS > barrier.x - barrier.width / 2 &&
                   tank.x - TANK_COLLISION_RADIUS < barrier.x + barrier.width / 2 &&
                   tank.y + TANK_COLLISION_RADIUS > barrier.y - barrier.height / 2 &&
                   tank.y - TANK_COLLISION_RADIUS < barrier.y + barrier.height / 2;
        }
        
        function handleTankHazardInteraction(tank, hazard, isPlayer1) {
            const currentTime = Date.now();
            
            if (hazard.type === 'lava') {
                // Damage over time for lava
                const lastDamageTime = hazard.lastDamageTime.get(tank) || 0;
                if (currentTime - lastDamageTime > LAVA_DAMAGE_RATE) {
                    hazard.lastDamageTime.set(tank, currentTime);
                    destroyTank(tank, isPlayer1);
                }
            } else if (hazard.type === 'teleporter' && hazard.partner && hazard.cooldown === 0) {
                // Teleport to partner location
                tank.x = hazard.partner.x;
                tank.y = hazard.partner.y;
                
                // Set cooldown for both teleporters
                hazard.cooldown = 60; // 1 second at 60fps
                hazard.partner.cooldown = 60;
                
                // Add teleport effect
                explosions.push(new TeleportEffect(hazard.x, hazard.y));
                explosions.push(new TeleportEffect(hazard.partner.x, hazard.partner.y));
                playTeleportSound();
            } else if (hazard.type === 'conveyor') {
                // Apply conveyor force to tank movement
                const forceX = hazard.direction === 0 ? hazard.force : hazard.direction === 2 ? -hazard.force : 0;
                const forceY = hazard.direction === 1 ? hazard.force : hazard.direction === 3 ? -hazard.force : 0;
                
                // Apply force but respect boundaries
                const newX = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.width - TANK_COLLISION_RADIUS, tank.x + forceX));
                const newY = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.height - TANK_COLLISION_RADIUS, tank.y + forceY));
                
                // Check for collisions before applying force
                let collision = false;
                const otherTank = isPlayer1 ? player2 : player1;
                
                if (Math.hypot(newX - otherTank.x, newY - otherTank.y) < (TANK_COLLISION_RADIUS * 2)) {
                    collision = true;
                }
                
                // Check barrier collisions
                for (const barrier of barriers) {
                    if (barrier.isDestroyed && barrier.isDestroyed()) continue;
                    if (newX + TANK_COLLISION_RADIUS > barrier.x - barrier.width/2 && 
                        newX - TANK_COLLISION_RADIUS < barrier.x + barrier.width/2 &&
                        newY + TANK_COLLISION_RADIUS > barrier.y - barrier.height/2 && 
                        newY - TANK_COLLISION_RADIUS < barrier.y + barrier.height/2) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    tank.x = newX;
                    tank.y = newY;
                }
            } else if (hazard.type === 'ice') {
                // Ice patch - make tank slippery and preserve momentum
                if (!hazard.tanksOnIce.has(tank)) {
                    hazard.tanksOnIce.set(tank, { 
                        velocityX: 0, 
                        velocityY: 0,
                        onIceTime: 0
                    });
                }
                
                const iceData = hazard.tanksOnIce.get(tank);
                iceData.onIceTime++;
                
                // Store tank's current momentum for sliding effect
                // This will be used in tank movement to create sliding
                tank.iceVelocityX = iceData.velocityX;
                tank.iceVelocityY = iceData.velocityY;
                tank.isOnIce = true;
            }
        }
        
        document.addEventListener('keydown', (e) => { 
            keys[e.code] = true; 
            
            // Handle special keys
            if (e.code === 'KeyR') {
                restartGame();
            } else if (e.code === 'Minus') {
                showDebugInfo = !showDebugInfo;
            } else if (e.code === 'KeyM') {
                toggleAudio();
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function restartGame() {
            // Reset scores
            player1Score = 0;
            player2Score = 0;
            
            // Clear game objects
            bullets.length = 0;
            explosions.length = 0;
            barriers.length = 0;
            hazards.length = 0;
            powerUps.length = 0;
            
            // Clear CTF objects
            redFlag = null;
            blueFlag = null;
            redBase = null;
            blueBase = null;
            
            // Reset power-up spawning
            lastPowerUpSpawn = Date.now();
            
            // Reinitialize tanks
            initializeTanks();
            
            // Regenerate map
            generateBarriers();
            
            // Update display
            updateScoreboard();
        }
        
        function handleTankMovement(tank, forwardKey, backwardKey, leftKey, rightKey, otherTank) {
             if (tank.isHit) return;
             const isPlayer1Tank = tank === player1;

            // --- Rotation ---
            if (keys[leftKey]) tank.rotate(-1);
            if (keys[rightKey]) tank.rotate(1);
            
            // --- Movement ---
            let moveDirection = 0;
            if (keys[forwardKey]) moveDirection = 1;
            if (keys[backwardKey]) moveDirection = -1;
            
            if (moveDirection !== 0) {
                const moveX = Math.cos(tank.angle) * TANK_SPEED * moveDirection;
                const moveY = Math.sin(tank.angle) * TANK_SPEED * moveDirection;
                const nextX = tank.x + moveX;
                const nextY = tank.y + moveY;

                // Play tank movement sound
                playTankMoveSound();

                let collision = false;
                // Barrier collision (using AABB with the TANK_COLLISION_RADIUS)
                for (const barrier of barriers) {
                    if (barrier.isDestroyed()) continue;
                    if (nextX + TANK_COLLISION_RADIUS > barrier.x - barrier.width/2 && nextX - TANK_COLLISION_RADIUS < barrier.x + barrier.width/2 &&
                        nextY + TANK_COLLISION_RADIUS > barrier.y - barrier.height/2 && nextY - TANK_COLLISION_RADIUS < barrier.y + barrier.height/2) {
                        if (barrier.type === 'moving') {
                            destroyTank(tank, isPlayer1Tank);
                        }
                        collision = true; break;
                    }
                }
                // Player collision (using circular collision for tanks)
                if (Math.hypot(nextX - otherTank.x, nextY - otherTank.y) < (TANK_COLLISION_RADIUS * 2)) {
                    collision = true;
                }

                if (!collision) {
                    tank.x = nextX;
                    tank.y = nextY;
                    
                    // Update ice velocity when moving on ice
                    if (tank.isOnIce) {
                        tank.iceVelocityX += moveX * ICE_SLIDE_FORCE;
                        tank.iceVelocityY += moveY * ICE_SLIDE_FORCE;
                        
                        // Apply friction to ice velocity
                        tank.iceVelocityX *= ICE_FRICTION;
                        tank.iceVelocityY *= ICE_FRICTION;
                        
                        // Cap maximum ice velocity
                        const maxIceVelocity = TANK_SPEED * 2;
                        const iceSpeed = Math.sqrt(tank.iceVelocityX * tank.iceVelocityX + tank.iceVelocityY * tank.iceVelocityY);
                        if (iceSpeed > maxIceVelocity) {
                            tank.iceVelocityX = (tank.iceVelocityX / iceSpeed) * maxIceVelocity;
                            tank.iceVelocityY = (tank.iceVelocityY / iceSpeed) * maxIceVelocity;
                        }
                    }
                }
            }

            // Clamp to screen bounds
            tank.x = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.width - TANK_COLLISION_RADIUS, tank.x));
            tank.y = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.height - TANK_COLLISION_RADIUS, tank.y));
            
            // Update tank tracks
            tank.updateTracks();
        }

        function handleInput() {
            // Player 1 controls (always active)
            handleTankMovement(player1, 'KeyW', 'KeyS', 'KeyA', 'KeyD', player2);
            if (keys['Space']) player1.fire();
           
            // Player 2 controls (in two-player mode and CTF mode)
            if (gameMode === 'twoPlayer' || gameMode === 'captureTheFlag') {
                handleTankMovement(player2, 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', player1);
                if (keys['Enter']) player2.fire();
            }
        }
        
        function checkCollisions() {
            bulletsLoop: for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Bullet-barrier collision (accounting for bullet radius)
                for (let j = barriers.length - 1; j >= 0; j--) {
                    const barrier = barriers[j];
                    if (barrier.isDestroyed()) continue;
                    
                    // Expand barrier bounds by bullet radius to prevent bullets slipping through gaps
                    if (bullet.x + bullet.radius > barrier.x - barrier.width / 2 && 
                        bullet.x - bullet.radius < barrier.x + barrier.width / 2 &&
                        bullet.y + bullet.radius > barrier.y - barrier.height / 2 && 
                        bullet.y - bullet.radius < barrier.y + barrier.height / 2) {
                        
                        // Pierce bullets go through barriers
                        if (bullet.pierce) {
                            // Damage breakable barriers but continue through
                            if (barrier.type === 'breakable') {
                                barrier.takeDamage();
                                if (barrier.isDestroyed()) {
                                    playBarrierBreakSound();
                                    barriers.splice(j, 1);
                                } else {
                                    playBarrierHitSound();
                                }
                            }
                            continue; // Don't stop the bullet
                        }
                        
                        if (barrier.type === 'breakable') {
                            const hadMoreThanOneHealth = barrier.health > 1;
                            barrier.takeDamage();
                            if (barrier.isDestroyed()) {
                                playBarrierBreakSound();
                                barriers.splice(j, 1);
                                bullets.splice(i, 1);
                                continue bulletsLoop;
                            }

                            playBarrierHitSound();

                            // Bounce bullets can bounce multiple times
                            if (bullet.bounces > 0) {
                                bounceBulletOffBarrier(bullet, barrier);
                                bullet.bounces--;
                                continue bulletsLoop;
                            } else if (!bullet.hasBounced && hadMoreThanOneHealth) {
                                bounceBulletOffBarrier(bullet, barrier);
                                bullet.hasBounced = true;
                                continue bulletsLoop;
                            }
                        } else {
                            playBarrierHitSound();
                            
                            // Bounce bullets can bounce multiple times
                            if (bullet.bounces > 0) {
                                bounceBulletOffBarrier(bullet, barrier);
                                bullet.bounces--;
                                continue bulletsLoop;
                            } else if (!bullet.hasBounced) {
                                bounceBulletOffBarrier(bullet, barrier);
                                bullet.hasBounced = true;
                                continue bulletsLoop;
                            }
                        }

                        bullets.splice(i, 1);
                        continue bulletsLoop;
                    }
                }

                // Bullet-tank collision
                const dist1 = Math.hypot(bullet.x - player1.x, bullet.y - player1.y);
                if (dist1 < TANK_COLLISION_RADIUS && !player1.isHit) { // Use TANK_COLLISION_RADIUS for bullet-tank
                    bullets.splice(i, 1);
                    destroyTank(player1, true);
                    continue; 
                }
                
                const dist2 = Math.hypot(bullet.x - player2.x, bullet.y - player2.y);
                if (dist2 < TANK_COLLISION_RADIUS && !player2.isHit) { // Use TANK_COLLISION_RADIUS for bullet-tank
                    bullets.splice(i, 1);
                    destroyTank(player2, false);
                    continue;
                }
                
                if (bullet.x - bullet.radius <= 0) {
                    if (!bullet.hasBounced) {
                        bullet.angle = Math.PI - bullet.angle;
                        bullet.x = bullet.radius + 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }

                if (bullet.x + bullet.radius >= canvas.width) {
                    if (!bullet.hasBounced) {
                        bullet.angle = Math.PI - bullet.angle;
                        bullet.x = canvas.width - bullet.radius - 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }

                if (bullet.y - bullet.radius <= 0) {
                    if (!bullet.hasBounced) {
                        bullet.angle = -bullet.angle;
                        bullet.y = bullet.radius + 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }

                if (bullet.y + bullet.radius >= canvas.height) {
                    if (!bullet.hasBounced) {
                        bullet.angle = -bullet.angle;
                        bullet.y = canvas.height - bullet.radius - 0.1;
                        bullet.hasBounced = true;
                        continue bulletsLoop;
                    }
                    bullets.splice(i, 1);
                    continue bulletsLoop;
                }
            }
        }
        
        function resetTank(tank, isPlayer1) {
            if(isPlayer1){
                tank.x = TANK_START_MARGIN;
                tank.y = canvas.height / 2;
                tank.angle = 0;
            } else {
                tank.x = canvas.width - TANK_START_MARGIN;
                tank.y = canvas.height / 2;
                tank.angle = Math.PI;
            }
            tank.isHit = false;
            
            // Clear active power-ups
            tank.activePowerUp = null;
            tank.powerUpEndTime = 0;
            
            // Clear tank tracks on reset
            tank.trackHistory = [];
            tank.lastTrackPosition = { x: tank.x, y: tank.y, angle: tank.angle };
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            handleInput();

            // Update barriers but don't draw them yet
            barriers.forEach(barrier => {
                barrier.update(barriers); // Pass all barriers for collision detection
                if (barrier.type === 'moving') {
                    if (!player1.isHit && tankOverlapsBarrier(player1, barrier)) {
                        destroyTank(player1, true);
                    }
                    if (!player2.isHit && tankOverlapsBarrier(player2, barrier)) {
                        destroyTank(player2, false);
                    }
                }
            });
            
            // Reset ice state for both tanks before checking hazards
            player1.isOnIce = false;
            player2.isOnIce = false;
            player1.iceVelocityX = player1.iceVelocityX || 0;
            player1.iceVelocityY = player1.iceVelocityY || 0;
            player2.iceVelocityX = player2.iceVelocityX || 0;
            player2.iceVelocityY = player2.iceVelocityY || 0;
            
            // Update and handle environmental hazards
            hazards.forEach(hazard => {
                hazard.update();
                hazard.draw();
                
                // Check tank interactions with hazards
                if (!player1.isHit && hazard.overlapsWithTank(player1)) {
                    handleTankHazardInteraction(player1, hazard, true);
                }
                if (!player2.isHit && hazard.overlapsWithTank(player2)) {
                    handleTankHazardInteraction(player2, hazard, false);
                }
            });
            
            // Apply ice momentum and friction when not on ice
            [player1, player2].forEach(tank => {
                if (!tank.isOnIce) {
                    // Apply stored ice momentum
                    if (Math.abs(tank.iceVelocityX) > 0.1 || Math.abs(tank.iceVelocityY) > 0.1) {
                        const newX = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.width - TANK_COLLISION_RADIUS, tank.x + tank.iceVelocityX));
                        const newY = Math.max(TANK_COLLISION_RADIUS, Math.min(canvas.height - TANK_COLLISION_RADIUS, tank.y + tank.iceVelocityY));
                        
                        // Check for collisions
                        const otherTank = tank === player1 ? player2 : player1;
                        let collision = false;
                        
                        if (Math.hypot(newX - otherTank.x, newY - otherTank.y) < (TANK_COLLISION_RADIUS * 2)) {
                            collision = true;
                        }
                        
                        for (const barrier of barriers) {
                            if (barrier.isDestroyed && barrier.isDestroyed()) continue;
                            if (newX + TANK_COLLISION_RADIUS > barrier.x - barrier.width/2 && 
                                newX - TANK_COLLISION_RADIUS < barrier.x + barrier.width/2 &&
                                newY + TANK_COLLISION_RADIUS > barrier.y - barrier.height/2 && 
                                newY - TANK_COLLISION_RADIUS < barrier.y + barrier.height/2) {
                                collision = true;
                                break;
                            }
                        }
                        
                        if (!collision) {
                            tank.x = newX;
                            tank.y = newY;
                        } else {
                            // Stop sliding on collision
                            tank.iceVelocityX = 0;
                            tank.iceVelocityY = 0;
                        }
                    }
                    
                    // Apply friction to reduce momentum
                    tank.iceVelocityX *= 0.9;
                    tank.iceVelocityY *= 0.9;
                }
            });
            
            // Update AI tank if in AI mode
            if (gameMode === 'vsAI' && player2 instanceof AITank) {
                player2.update(player1);
            }
            
            // Handle power-up spawning
            const now = Date.now();
            if (now - lastPowerUpSpawn > POWERUP_SPAWN_INTERVAL) {
                spawnPowerUp();
                lastPowerUpSpawn = now;
            }
            
            // Update and draw power-ups
            powerUps.forEach((powerUp, index) => {
                if (!powerUp.collected) {
                    powerUp.update();
                    powerUp.draw();
                    
                    // Check collision with player 1
                    if (!player1.isHit && powerUp.checkCollision(player1)) {
                        const powerUpData = powerUp.collect();
                        player1.collectPowerUp(powerUpData);
                        playPowerUpSound();
                    }
                    
                    // Check collision with player 2
                    if (!player2.isHit && powerUp.checkCollision(player2)) {
                        const powerUpData = powerUp.collect();
                        player2.collectPowerUp(powerUpData);
                        playPowerUpSound();
                    }
                }
            });
            
            // Remove collected power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                if (powerUps[i].collected) {
                    powerUps.splice(i, 1);
                }
            }
            
            // CTF game mode logic
            if (gameMode === 'captureTheFlag' && redFlag && blueFlag && redBase && blueBase) {
                // Update flags and bases
                redFlag.update();
                blueFlag.update();
                redBase.update();
                blueBase.update();
                
                // Draw bases first (behind flags)
                redBase.draw();
                blueBase.draw();
                
                // Check flag interactions
                if (!player1.isHit) {
                    // Player 1 (red team) interactions
                    if (blueFlag.checkCollision(player1)) {
                        const result = blueFlag.pickup(player1);
                        if (result === 'captured') {
                            playPowerUpSound(); // Reuse sound for flag pickup
                        }
                    }
                    
                    if (redFlag.checkCollision(player1)) {
                        const result = redFlag.pickup(player1);
                        if (result === 'returned') {
                            playTeleportSound(); // Different sound for flag return
                        }
                    }
                    
                    // Check for scoring (carrying enemy flag to own base)
                    if (blueFlag.carriedBy === player1 && redBase.checkCollision(player1)) {
                        // Score for red team!
                        player1Score++;
                        updateScoreboard();
                        blueFlag.returnToBase();
                        playFlagCaptureSound(); // Exciting victory sound
                    }
                }
                
                if (!player2.isHit) {
                    // Player 2 (blue team) interactions
                    if (redFlag.checkCollision(player2)) {
                        const result = redFlag.pickup(player2);
                        if (result === 'captured') {
                            playPowerUpSound();
                        }
                    }
                    
                    if (blueFlag.checkCollision(player2)) {
                        const result = blueFlag.pickup(player2);
                        if (result === 'returned') {
                            playTeleportSound();
                        }
                    }
                    
                    // Check for scoring (carrying enemy flag to own base)
                    if (redFlag.carriedBy === player2 && blueBase.checkCollision(player2)) {
                        // Score for blue team!
                        player2Score++;
                        updateScoreboard();
                        redFlag.returnToBase();
                        playFlagCaptureSound(); // Exciting victory sound
                    }
                }
                
                // Draw flags (on top of bases)
                redFlag.draw();
                blueFlag.draw();
            }
            
            bullets.forEach(bullet => {
                bullet.update();
                bullet.draw();
            });
            checkCollisions();

            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.update();
                explosion.draw();
                if (explosion.isFinished()) {
                    explosions.splice(i, 1);
                }
            }

            // Draw all tank tracks first (behind everything)
            player1.drawTracks();
            player2.drawTracks();
            
            // Draw tank bodies on top of tracks
            player1.drawBody();
            player2.drawBody();
            
            // Draw barriers last so they appear on top of everything
            barriers.forEach(barrier => {
                barrier.draw();
            });
            
            // Draw debug info if enabled
            if (showDebugInfo) {
                drawDebugInfo();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function drawDebugInfo() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 200, 150);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('Debug Info (Press - to toggle)', 15, 25);
            ctx.fillText(`Game Mode: ${gameMode}`, 15, 45);
            ctx.fillText(`P1: ${Math.round(player1.x)}, ${Math.round(player1.y)}`, 15, 65);
            ctx.fillText(`P2: ${Math.round(player2.x)}, ${Math.round(player2.y)}`, 15, 85);
            ctx.fillText(`Bullets: ${bullets.length}`, 15, 105);
            ctx.fillText(`Barriers: ${barriers.length}`, 15, 125);
            ctx.fillText(`Hazards: ${hazards.length}`, 15, 145);
            
            if (gameMode === 'vsAI' && player2 instanceof AITank) {
                ctx.fillText(`AI Target Distance: ${Math.round(Math.hypot(player2.target?.x - player2.x || 0, player2.target?.y - player2.y || 0))}`, 15, 165);
            }
        }
        
        let showDebugInfo = false;

        // Game mode selection event handlers
        document.getElementById('twoPlayerBtn').addEventListener('click', function() {
            gameMode = 'twoPlayer';
            startGame();
        });

        document.getElementById('vsAIBtn').addEventListener('click', function() {
            gameMode = 'vsAI';
            startGame();
        });

        document.getElementById('ctfBtn').addEventListener('click', function() {
            gameMode = 'captureTheFlag';
            startGame();
        });

        function startGame() {
            // Hide mode selection and show game
            document.getElementById('gameModeSelector').style.display = 'none';
            document.getElementById('scoreboard').style.display = 'block';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            
            // Initialize audio system
            initializeAudio();
            
            // Update controls text based on game mode
            updateControlsText();
            
            // Initialize the game
            initializeTanks();
            generateBarriers();
            updateScoreboard();
            gameRunning = true;
            gameLoop();
        }

        function updateControlsText() {
            const controls = document.getElementById('controls');
            if (gameMode === 'twoPlayer') {
                controls.innerHTML = `
                    <div><strong style="color: #e74c3c; text-shadow: 0 0 8px rgba(231, 76, 60, 0.6);">Player 1:</strong> WASD to move, Space to shoot</div>
                    <div><strong style="color: #3498db; text-shadow: 0 0 8px rgba(52, 152, 219, 0.6);">Player 2:</strong> Arrow keys to move, Enter to shoot</div>
                    <div>Press 'R' to restart, '-' for debug info, 'M' to toggle audio</div>
                `;
            } else if (gameMode === 'vsAI') {
                controls.innerHTML = `
                    <div><strong style="color: #e74c3c; text-shadow: 0 0 8px rgba(231, 76, 60, 0.6);">Player:</strong> WASD to move, Space to shoot</div>
                    <div><strong style="color: #3498db; text-shadow: 0 0 8px rgba(52, 152, 219, 0.6);">AI:</strong> Controlled by computer</div>
                    <div>Press 'R' to restart, '-' for debug info, 'M' to toggle audio</div>
                `;
            } else if (gameMode === 'captureTheFlag') {
                controls.innerHTML = `
                    <div><strong style="color: #e74c3c; text-shadow: 0 0 8px rgba(231, 76, 60, 0.6);">Red Team:</strong> WASD to move, Space to shoot</div>
                    <div><strong style="color: #3498db; text-shadow: 0 0 8px rgba(52, 152, 219, 0.6);">Blue Team:</strong> Arrow keys to move, Enter to shoot</div>
                    <div><strong>Objective:</strong> Capture the enemy flag and return it to your base!</div>
                    <div>Press 'R' to restart, '-' for debug info, 'M' to toggle audio</div>
                `;
            }
        }

        // Don't start the game immediately - wait for mode selection
        // generateBarriers();
        // updateScoreboard();
        // gameLoop();
    </script>
</body>
</html>
